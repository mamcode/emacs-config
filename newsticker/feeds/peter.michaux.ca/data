;; -*- coding: utf-8 -*-
(("peter.michaux.ca" nil nil (20852 16596 373117) feed 0 nil nil ((id nil "http://peter.michaux.ca/") (title nil "peter.michaux.ca") (updated nil "2012-10-26T23:17:00-07:00") (link ((href . "/feed/atom.xml") (rel . "self") (type . "application/atom+xml"))) (link ((href . "/") (rel . "alternate") (type . "text/html"))) (entry nil (id nil "http://peter.michaux.ca/articles/early-mixins-late-mixins") (title nil "Early Mixins, Late Mixins") (updated nil "2012-10-26T23:17:00Z") (link ((href . "/articles/early-mixins-late-mixins") (rel . "alternate") (type . "text/html"))) (content ((type . "html")) "<p>In JavaScript, the language supplies us with several code reuse patterns. Prototype chaining gives us the primary single inheritance mechanism. Mixins are also an important pattern when we want one object to &ldquo;inherit&rdquo; functionality from multiple objects. There are several ways to implement the mixin process. This article looks at two contrasting implementations: early mixins and late mixins.</p>

<h2>Late Binding</h2>

<p>Let&rsquo;s start with a quick review of what late binding gives us.</p>

<pre><code>var adam = {
    greet: function() {
        return \"hello\";
    }
};

adam.greet(); // \"hello\"</code></pre>

<p>When we ask <code>adam</code> to <code>greet</code>, the method to be executed is looked up at the time of the call. This is late binding and means if we redefine the greet method, subsequent calls will use the new definition.</p>

<pre><code>adam.greet = function(name) {
    return \"hello\" + (name ? (\", \" + name) : \"\");
};

adam.greet(\"world\"); // \"hello, world\";</code></pre>

<p>This ability to redefine a method is valuable because it makes it possible for plugins to modify the behaviour of an existing code library.</p>


<h2>Late Binding and Prototype Chaining</h2>

<p>How does late binding work with prototype chaining? Let&rsquo;s start with a fresh example. First we&rsquo;ll make a new object <code>adam</code> who introduces himself.</p>

<pre><code>var adam = {
    _name: \"Adam\";
    greet: function() {
        return \"hello. I am \" + this._name;
    }
};</code></pre>

<p>Someone named Adam seems like a suitable prototype for all existing people. We can make a constructor function to produce more people.</p>

<pre><code>function Person(name) {
    this._name = name;
}
Person.prototype = adam;

var eve = new Person(\"Eve\");
eve.greet(); // \"hello. I am Eve\"</code></pre>

<p>Thanks to the combination of late binding and the prototype chain, a change to <code>adam</code> will result in a change to <code>eve</code> instantly. The following could be some plugin for the library that provides the <code>adam</code> object. This redefinition could happen at runtime due to user interaction.</p>

<pre><code>adam.greet = function(name) {
    return \"hello\" + (name ? (\", \" + name) : '') + \". I am \" + this._name;
};

eve.greet(\"world\"); // \"hello, world. I am Eve\"</code></pre>


<h2>Early Mixins</h2>

<p>Another way to create a reusable bunch of code as a library is to provide one object who&rsquo;s properties can be mixed into another object. This is usually done with an early mixin implementation.</p>

<p>First, a generic function that can mix properties from one object into another object.</p>

<pre><code>function earlyMixin(sink, source) {
    for (var property in source) {
        sink[property] = source[property];
    }
}</code></pre>

<p>Now a object containing methods that would be useful on another object. Here is a library called Speeches.JS.</p>

<pre><code>var speeches = {
    greet: function() {
        return \"hello. I am \" + this._name;
    },
    farewell: function() {
        return \"goodbye. I am \" + this._name;
    }
};</code></pre>

<p>Since this Speeches.JS library is already written and well unit tested, we&rsquo;d like to reuse that code in our code.</p>

<pre><code>function Person(name) {
    this._name = name;
}
earlyMixin(Person.prototype, speeches);

var adam = new Person('Adam');
adam.greet(); // \"hello. I am Adam\"</code></pre>

<p>Now suppose we have mixed this <code>speeches</code> object into several other objects (like the <code>Person.prototype</code> object.) Also suppose we want to modify the <code>speeches</code> object at some later time and have all objects who&rsquo;ve had the <code>speeches</code> object mixed into it be updated. This is what a plugin for Speeches.JS might want to do.</p> 

<pre><code>speeches.greet = function(name) {
    return \"hello\" + (name ? (\", \" + name) : '') + \". I am \" + this._name;
};</code></pre>

<p>Unfortunately we cannot do this because the <code>speeches</code> methods have been mixed into the <code>Person.prototype</code> object early (i.e. at the time of mixin.) We still have</p>

<pre><code>adam.greet(\"world\"); // \"hello. I am Adam\"</code></pre>

<h2>Late Mixins</h2>

<p>In order to make it possible to modify <code>speeches</code> and have all objects use the modified methods, we need one level of indirection in the mixin process.</p>

<pre><code>function lateMixin(sink, source) {
    for (var property in source) {
        (function(property) {
            sink[property] = function() {
                return source[property].apply(this, arguments);
            }
        }(property));
    }
}</code></pre>

<p>Instead of directly borrowing the methods of the <code>source</code>, the <code>sink</code> is given methods that call the methods of <code>source</code>. This means that the method on <code>source</code> are mixed in late because they are looked up when they are called (rather than when they are mixed in.)</p>

<p>Now we can go through the same example with a different result.</p>

<pre><code>var speeches = {
    greet: function() {
        return \"hello. I am \" + this._name;
    },
    farewell: function() {
        return \"goodbye. I am \" + this._name;
    }
};

function Person(name) {
    this._name = name;
}
lateMixin(Person.prototype, speeches);

var adam = new Person('Adam');
adam.greet(); // \"hello. I am Adam\"

speeches.greet = function(name) {
    return \"hello\" + (name ? (\", \" + name) : '') + \". I am \" + this._name;
};

adam.greet(\"world\"); // \"hello, world. I am Adam\"</code></pre>

<p>When <code>adam.greet</code> is called it uses the most recent definition of <code>speeches.greet</code>. Yay! Late mixins have given us the same dynamic power that late binding and the prototype chain give us. This makes a library like Speeches.JS more flexible and opens it up for various kinds of modification at run time.</p>

<h2>Not Quite Everything</h2>

<p>Late mixins give us some of the power of late binding and the prototype chain but not everything. If we add another method to the <code>speeches</code> object it is not added to the other objects into which <code>speeches</code> has been mixed. There are several ways to accomplish this type of functionality. Something like <a href=\"http://wiki.ecmascript.org/doku.php?id=harmony%3adirect_proxies\" target=\"_blank\">proxies</a> might be our answer to get closer to real multiple inheritance.</p>
")) (entry nil (id nil "http://peter.michaux.ca/articles/uMVC") (title nil "uMVC - A micro MVC framework in JavaScript") (updated nil "2012-10-13T20:00:00Z") (link ((href . "/articles/uMVC") (rel . "alternate") (type . "text/html"))) (content ((type . "html")) "<p><a href=\"https://twitter.com/petermichaux/status/221671174915104768\" title=\"@petermichaux on Twitter\" target=\"_blank\">I tweeted:</a></p>

<blockquote>
<p>You can write an MVC framework in one hundred lines of JavaScript &amp; write about its effective use for one hundred thousand lines of English.</p>
</blockquote>

<p>I wondered exactly how small I could write a respectable MVC framework that included the three fundamental design patterns of the traditional Smalltalk-style MVC: the observer, composite, and strategy patterns.</p>

<p>See <a href=\"https://github.com/petermichaux/uMVC/blob/master/uMVC.js\" target=\"_blank\">the uMVC code on Github</a>.</p>

<p>Hopefully this code is educational for those new to the MVC paradigm. I think this code is something every JavaScript programmer should understand inside out and be able to explain every individual line&rsquo;s significance to another programmer new to MVC.</p>

<p>If you are looking for a more fully-featured MVC framework that follows the same principles of uMVC to use in real browser applications, I suggest you take a look at <a href=\"https://github.com/petermichaux/maria\" target=\"_blank\">Maria</a>.</p>
")) (entry nil (id nil "http://peter.michaux.ca/articles/less-English-more-JavaScript") (title nil "Less English, more JavaScript") (updated nil "2012-10-13T19:00:00Z") (link ((href . "/articles/less-English-more-JavaScript") (rel . "alternate") (type . "text/html"))) (content ((type . "html")) "<p>I haven&rsquo;t written much for my website this year. It wasn&rsquo;t an accident. I wasn&rsquo;t too busy. It was a choice. My new year&rsquo;s resolution for 2012 was to write less English and more JavaScript.</p>

<p>Three quarters of the year is now gone and I feel like I&rsquo;ve satisfied that resolution with 11 new JavaScript repositories <a href=\"https://github.com/petermichaux\" target=\"_blank\">on Github</a>. Most of the work was driven by the development of the <a href=\"https://github.com/petermichaux/maria\" target=\"_blank\">Maria framework</a> for writing MVC-style browser application. That particular project has been great fun and satisfying.</p>

<p>Now I feel as through I should tell the world about these projects &hellip; but part of me just wants to continue writing more JavaScript.</p>

")) (entry nil (id nil "http://peter.michaux.ca/articles/organizing-browser-application-files") (title nil "Organizing Browser Application Files") (updated nil "2012-10-12T23:00:00Z") (link ((href . "/articles/organizing-browser-application-files") (rel . "alternate") (type . "text/html"))) (content ((type . "html")) "<p>If you are building a large, one-page browser application with the usual suspects of HTML, CSS, JavaScript, images, etc, you&rsquo;ll have many files and staying organized is important. Here is a way to organize your files.</p>


<h2>General Structure</h2>

<pre><code>MyApp/
    Makefile
    README
    etc/
    lib/
    src/
    tst/</code></pre>

<p>Perhaps the first thing you will do when starting the project is fill the <code>lib</code> directory with all the third-party libraries you know you&rsquo;ll be using. These libraries are dropped into the <code>lib</code> directory without modification. Just plop them there in the same form they are distributed. You aren&rsquo;t allowed to edit these files. This directory is the only directory where you put files created by a third party.</p>

<p>The <code>src</code> directory contains all of the files that you create and write that will become part of the files downloaded by the browser of a user of your application. These are the files we are excited about writing.</p>

<p>The <code>tst</code> directory contains all the files that test the files in the <code>src</code> directory. These are the files we are not excited about writing.</p>

<p>The <code>Makefile</code> has a default <code>build</code> target that generates the directory called <code>bld</code> which is filled with production-ready files that can be copied to the production web servers. The files in the <code>lib</code> and <code>src</code> directories are combined, minified, compressed, and otherwise mutated to become the files in the <code>bld</code> directory. This target can possibly generate a <code>MyApp.tar.gz</code> file if that is how the distribution to production will be done.</p>

<p>The build process may be guided by data in files in the <code>etc</code> directory. For example, there may be manifest files that state which files are concatenated together during the build and the name of the resulting files. Exactly which files with which data are in your <code>etc</code> directory depend on which tools you are using in your build process.</p>

<p>The <code>Makefile</code> should have a <code>clean</code> target that deletes the <code>bld</code> directory.</p>

<p>The <code>Makefile</code> might have a <code>test</code> target that runs the tests in the <code>tst</code> directory.</p>

<p>The <code>README</code> should at least explain what the targets in the Makefile do and how to run the tests.</p>

<p>You should not need to run <code>make build</code> in order to test your application either with the files in the <code>tst</code> directory or in the browser while developing. You may have files in your <code>etc</code> directory that control how the development environment is configured.</p>


<h2>An MVC-style Application</h2>

<p>You might be using an MVC framework like <a href=\"https://github.com/petermichaux/maria\" target=\"_blank\">Maria</a> to help structure your JavaScript. In this case, there is a natural way to divide your application at a finer scale.</p>

<pre><code>MyApp/
    Makefile
    README
    etc/
    lib/
        maria.js
    src/
        css/
        html/
            index.html
            templates/
        img/
        js/
            bootstrap.js
            controllers/
            models/
            views/
            util/
    tst/</code></pre>

<p>The <code>index.html</code> files is the page that the user loads into their browser to start the one-page application. This may be named something different like <code>myapp.html</code>. This file loads the necessary CSS, image, template, and JavaScript files needed to run the application.</p>

<p>The <code>templates</code> directory contains any HTML templates used by your JavaScript views. These can be compiled to JavaScript and concatenated into one or a few JavaScript files during the build process.</p>

<p>The <code>bootstrap.js</code> file is the one with the call to <code>window.onload</code> that fires up the whole application. It will start the loading of the data from the server, create the model layer, build the views, and add those views to the page so the user can begin interacting with the application.</p>

<p>The <code>controllers</code>, <code>models</code>, and <code>views</code> directories contain the obvious.</p>

<p>The <code>util</code> directory contains utility code that is not specific to any of the model, view, or controller layers. There may be pure functions that make computations with no side effects. You might have some obscure DOM related utilities that you wish were written by a third party for your <code>lib</code> directory but that you have to write yourself for your unique browser scripting requirements.</p>

")) (entry nil (id nil "http://peter.michaux.ca/articles/mixins-and-constructor-functions") (title nil "Mixins and Constructor Functions") (updated nil "2012-04-23T20:16:00Z") (link ((href . "/articles/mixins-and-constructor-functions") (rel . "alternate") (type . "text/html"))) (content ((type . "html")) "<p>JavaScript allows programmers to take properties from one object and mix them into another object. There are several ways to accomplish this mixing and a few of them are explored here.</p>


<h2>Observable Mixin</h2>

<p>Here is a simple example of the observer pattern that can be mixed into other objects.</p>

<pre><code>var observableMethods = {
    observe: function(observer) {
        if (!this.hasOwnProperty('observers')) {
            this.observers = [];
        }
        this.observers.push(observer);
    },
    notify: function(data) {
        if (this.hasOwnProperty('observers')) {
            for (var i=0, ilen=this.observers.length; i&lt;ilen; i++) {
                this.observers[i](data);
            }
        }
    }
};</code></pre>

<p>It is possible to use the <code>observableMethods</code> function as a observable itself.</p>

<pre><code>observableMethods.observe(function() {
    alert('hi');
});
observableMethods.notify();</code></pre>

<p>A little mixin function to make other things observable.</p>

<pre><code>function mixinObservable(sink) {
    for (var p in observableMethods) {
        if (observableMethods.hasOwnProperty(p) &amp;&amp;
            typeof observableMethods[p] === 'function') {
            sink[p] = observableMethods[p];
        }
    }
}</code></pre>

<p>We can mixin to an person created with an object literal.</p>

<pre><code>var person = {
    name: 'Steve',
    setName: function(name) {
        var oldName = this.name;
        this.name = name;
        this.notify({oldName: oldName, newName: this.name});
    }
};
mixinObservable(person);
person.observe(function(data) {
    alert(data.oldName + ' was renamed to ' + data.newName);
});
person.setName('Sarah');</code></pre>

<p>Alternately we write a constructor function for observable people that we can rename.</p>

<pre><code>function Person(name) {
    this.setName(name);
};

mixinObservable(Person.prototype);

Person.prototype.setName = function(name) {
    var oldName = this.name;
    this.name = name;
    this.notify({oldName:oldName, newName:this.name});
};</code></pre>

<p>We can then make a person and manipulate it.</p>

<pre><code>var person = new Person('Steve');
person.observe(function(data) {
    alert(data.oldName + ' was renamed to ' + data.newName);
});
person.setName('Sarah');</code></pre>

<p>In all of the above code, the three uses of <code>hasOwnProperty</code> are critical to understand.</p>

<p>The first two uses of <code>hasOwnProperty</code> in <code>observe</code> and <code>notify</code> ensure that the object into which the methods have been mixed, will have its own set observers and not share some set of observers with any other object. The unfortunate part is that these checks run every time the <code>observe</code> and <code>notify</code> methods are called. This is inefficient and something we want to fix.</p>

<p>The third use of <code>hasOwnProperty</code> in <code>mixinObservable</code> means that only properties directly on <code>observableMethods</code> will be mixed into other objects. This is important because if we do not use <code>hasOwnProperty</code> then we copy all of the enumerable <code>Object.prototype</code> properties which is either wasteful or will overwrite any custom methods with the same names on other objects.</p>

<p>The <code>mixinObservable</code> function also copies only functions. If this check was not made and someone had observed the <code>observableMethods</code> object itself then the <code>observableMethods.observes</code> array would be copied as part of every mixin and observers would be shared by some observable objects (e.g. <code>observableMethods</code> and <code>Person.prototype</code> in the example above.)</p>

<p>A simpler <code>mixinObservable</code> method could be the following but this could be more difficult to maintain. If more methods are added to <code>observableMethods</code> then they need to be explicitly listed in <code>mixinObservable</code>.</p>

<pre><code>function mixinObservable(sink) {
    sink.observe = observableMethods.observe;
    sink.notify = observableMethods.notify;
}</code></pre>

<h2>Fixing the Inefficiency</h2>

<p>The inefficiency in <code>observe</code> and <code>notify</code> can be fixed by making a constructor function for <code>Observable</code> objects.</p>

<pre><code>function Observable() {
    this.observers = [];
}
Observable.prototype.observe = function(observer) {
    this.observers.push(observer);
};
Observable.prototype.notify = function(data) {
    for (var i=0, ilen=this.observers.length; i&lt;ilen; i++) {
        this.observers[i](data);
    }
};
Observable.call(Observable.prototype); // optional depending what you want</code></pre>

<p>Now the <code>observe</code> and <code>notify</code> methods of an observable function are more efficient as we know the <code>observers</code> property was created when the <code>Observable</code> constructor function ran.</p>

<p>The last line, <code>Observable.call(Observable.prototype);</code>, is a bit of an unusual one but it makes it possible to observe <code>Observable.prototype</code> just like <code>observableMethods</code>.</p>

<p>A new mixin function.</p>

<pre><code>function mixinObservable(sink) {
    for (var p in Observable.prototype) {
        if (Observable.prototype.hasOwnProperty(p) &amp;&amp;
            typeof Observable.prototype[p] === 'function') {
            sink[p] = Observable.prototype[p];
        }
    }
    Observable.call(sink); // optional depending what you want
}</code></pre>

<p>Mixing into a person created with an object literal just like it was done above. The last line of this new <code>mixinObservable</code> insures the <code>observers</code> property is created.</p>

<pre><code>var person = {
    name: 'Steve',
    setName: function(name) {
        var oldName = this.name;
        this.name = name;
        this.notify({oldName: oldName, newName: this.name});
    }
};
mixinObservable(person);
person.observe(function(data) {
    alert(data.oldName + ' was renamed to ' + data.newName);
});
person.setName('Sarah');</code></pre>

<p>The trick comes when we create a <code>Person</code> constructor function.</p>

<pre><code>function Person(name) {
    Observable.call(this);
    this.setName(name);
};

mixinObservable(Person.prototype);

Person.prototype.setName = function(name) {
    var oldName = this.name;
    this.name = name;
    this.notify({oldName:oldName, newName:this.name});
};</code></pre>

<p>The first line of the constructor function, <code>Observable.call(this);</code>, ensures that each <code>Person</code> object has its own set of observers. Without this call, all the people will share the same list of observers which is the set of observers on the <code>Person.prototype</code> object. If this makes you squint then it is well worth the effort to think about it until it is clear why.</p>

<p>To use some class vocabulary, the first line of the constructor function can be thought of as a <code>super</code> call and that the Person class inherits from the Observable class. Some JavaScript diehards cringe at the mention of this vocabulary but I think the comparison is worth consideration.</p>


<h2>Multiple Mixins</h2>

<p>Multiple mixins follow the same pattern.</p>

<pre><code>function Person(name) {
    Observable.call(this);
    Common.call(this);
    this.setName(name);
}

mixinObservable(Person.prototype);
mixinCommon(Person.prototype);

// By coincidence mixinCommon also added a notify method which
// clobbered the method of the same name added by mixinObservable.
// Fix this problem making appropriate decisions about how
// to call both.
Person.prototype.notify = function() {
    Common.prototype.notify.call(this);
    Observable.prototype.notify.apply(this, arguments);
};
// ...</code></pre>


<h2>Prototype Chaining vs. Mixins</h2>

<p>There is one primary difference between prototype chaining and mixins. For example,</p>

<pre><code>function Person(name) {
    Observable.call(this);
    Base.call(this);
    this.setName(name);
}

// chain prototypes so that all Person objects
// inherit from Base.prototype.
Person.prototype = Object.create(Base.prototype);
Person.prototype.constructor = Person;
Base.call(Person.prototype); // optional depending what you want

mixinObservable(Person.prototype);</code></pre>

<p>Now if we add methods to both <code>Base.prototype</code> and <code>Observable.prototype</code> <em>after</em> the above code has executed. Only the method added to <code>Base.prototype</code> will be added to <code>Person</code> objects.</p>

<pre><code>Base.prototype.getId = function() {/*...*/};
Observable.prototype.getObservers = function() {/*...*/};

var person = new Person('Steve');
person.getId(); // ok
person.getObservers(); // error: getObservers not defined</code></pre>

<p>Enjoy your mixins.</p>

")) (entry nil (id nil "http://peter.michaux.ca/articles/our-backwards-dom-event-libraries") (title nil "Our Backwards DOM Event Libraries") (updated nil "2012-03-03T20:46:00Z") (link ((href . "/articles/our-backwards-dom-event-libraries") (rel . "alternate") (type . "text/html"))) (content ((type . "html")) "<h2>The Browser APIs</h2>

<p>A brief review of what the browsers give us to attach event listeners to DOM elements so we can do fancy stuff when the user interacts with the page.</p>

<p>Internet Explorer gives us <code>element.attachEvent</code> allowing us to attach a listener <em>function</em> to an element.</p>

<pre><code>document.body.attachEvent(
    'onclick',
    function() {
        alert('body clicked');
    });
</code></pre>

<p>The other browsers give us <code>element.addEventListener</code>. The use with which we are most familiar is supplying a listener <em>function</em> as the second argument.<p>

<pre><code>document.body.addEventListener(
    'click',
    function() {
        alert('body clicked');
    },
    false);
</code></pre>

<p>Many JavaScript programmers don&rsquo;t know that it is also possible to send a listener <em>object</em> as the second argument to <code>addEventListener</code>. When an event is fired, the object&rsquo;s <code>handleEvent</code> method is called.</p>

<pre><code>document.body.addEventListener(
    'click',
    {
        handleEvent: function() {
            alert('body clicked');
        }
    },
    false);
</code></pre>

<p>An important feature of using a listener <em>object</em> is that the function value of it&rsquo;s <code>handleEvent</code> property is only looked up when the event is fired. This means that if the function value of the <code>handleEvent</code> property changes between events then it is always the current value of the <code>handleEvent</code> property that is called. This is late binding. For example,</p>

<pre><code>var obj = {};

document.body.addEventListener('click', obj, false);

// click body will error in some browsers because
// no handleEvent method on obj

obj.handleEvent = function() {alert('alpha');};

// click body and see alert \"alpha\"

obj.handleEvent = function() {alert('beta');};

// click body and see alert \"beta\"

document.body.removeEventListener('click', obj, false);

// click body and see nothing
</code></pre>

<h2>Cross-Browser Libraries</h2>

<p>Our cross-browser applications should not be cluttered with repetitive code to work with the different APIs provided by the different browsers, so we&rsquo;ve abstracted the different APIs away in event libraries. This has been a very good choice.</p>

<p>Different libraries have different APIs but every library has something like the following.</p>

<pre><code>LIB_addEventListener(
    document.body, 
    'click', 
    function() {
        alert('body clicked');
    });
</code></pre>

<h2>The JavaScript <code>this</code> Wrinkle</h2>
    
<p>A common problem with these library abstractions is when we want a method of an view object to be called when the event is fired. For example, in the following code, the value of <code>this</code> in the <code>handleClick</code> method is the global <code>window</code> object. The alert will show <code>undefined</code> when we may have expected to see the alert show <code>\"alpha\"</code>.</p>

<pre><code>function ViewObject() {
    this.data = 'alpha';
    LIB_addEventListener(
        document.body, 
        'click', 
        this.handleClick);
}
ViewObject.prototype.handleClick = function() {
    alert(this.data);
};
</code></pre>

<p>The workaround the libraries have given us (so that we can also still easily remove event listeners) is to specify the object we want as <code>this</code> when the handler is called as an extra argument to the event library function. For example, the alert in this example will show <code>\"alpha\"</code>.</p>

<pre><code>function ViewObject() {
    this.data = 'alpha';
    LIB_addEventListener(
        document.body, 
        'click', 
        this.handleClick,
        this);
}
ViewObject.prototype.handleClick = function() {
    alert(this.data);
};
ViewObject.prototype.destroy = function() {
    LIB_removeEventListener(
        document.body,
        'click',
        this.handleClick,
        this
    );
};
</code></pre>

<p>One problem with this API is that the listener <em>function</em> is bound when <code>LIB_addEventListener</code> is called. This causes trouble when the function value of <code>handleClick</code> is changed and then also when an attempt is made to remove the listener.</p>

<pre><code>var vo = new ViewObject();

// click on the body and see alert \"alpha\"

vo.handleClick = function() {
    alert('beta');
};

// click on the body and still see \"alpha\"

vo.destroy();

// click on the body and still see \"alpha\"!
</code></pre>

<p>Another problem is that we are writing the program in an object-oriented style but we are focusing on listener <em>functions</em> rather than listener <em>objects</em>. This mismatch is a clue to find a better solution.</p>

<h2>A Library API for Listener Objects</h2>

<p>Since we are frequently writing our programs in an object-oriented style, it makes sense to write <code>LIB_addEventListener</code> so that it can accept listener <em>objects</em> (as well as listener <em>functions</em>.)</p>

<pre><code>var obj = {
    handleEvent: function() {
        alert('click handler');
    }
};
LIB_addEventListener(document.body, 'click', obj);
</code></pre>

<p>Frequently we have one view object handling multiple types of events for various elements. A fourth parameter specifying the method name would allow that easily and still keep late binding.</p>

<pre><code>var obj = {
    handleMouseDown: function() {
        alert('mouse down handler');
    },
    handleMouseUp: function() {
        alert('mouse up handler');
    }
};
LIB_addEventListener(document.body, 'mousedown', obj, 'handleMouseDown');
LIB_addEventListener(document.body, 'mouseup', obj, 'handleMouseUp');
</code></pre>

<p>This API still allows for listener <em>functions</em> by looking at the type of the third argument.</p>

<pre><code>LIB_addEventListener(document.body, 'mousedown', function() {
    alert('mousedown');
});
</code></pre>

<p>But now there is no need for specifying the <code>this</code> object that will be used when the listener <em>function</em> is called because we have something better suited to the task: listener <em>objects</em>.</p>

")) (entry nil (id nil "http://peter.michaux.ca/articles/scheme-from-scratch-royal-scheme-v0_1-integers") (title nil "Scheme from Scratch - Royal Scheme v0.1 - Integers") (updated nil "2011-07-29T17:50:00Z") (link ((href . "/articles/scheme-from-scratch-royal-scheme-v0_1-integers") (rel . "alternate") (type . "text/html"))) (content ((type . "html")) "<p>It took a while but the plan is back on track. Royal Scheme is a go.</p>

<p>I&rsquo;ve been picking away at the project at a leisurely pace trying to determine exactly what it will be. Blog articles seem like a great way to keep folks informed about the state of development. Hopefully some folks will want to follow along creating their own implementations again like they did with Bootstrap Scheme. It was a whole bunch of fun.</p>

<p>I think a book format would be a better format for truly documenting the iterative development of a real Scheme interpreter that is implemented in C. I still haven&rsquo;t found that book and if I was taking a university course then I&rsquo;d want to take the course that has that book as its primary text. So a lot of what Royal Scheme development will be about is ensuring the order of introducing features is just right and that the concepts underlying the implementation are explained in code comments and in a book. It is a lofty goal. We&rsquo;ll see how it goes. I&rsquo;m hoping for feedback from you.</p>

<p>Just as Bootstrap Scheme started with integers, so does Royal Scheme.</p>

<pre><code>$ ./scm
Welcome to Royal Scheme. Ctrl-c to exit.
> 123
123
> -123
-123
> +007
7
> ^C
$</code></pre>

<p>I&rsquo;ve put the code on github. I&rsquo;m new to git and github which adds a bit more flavor to the project. You can browse the code at the following address</p>

<p><a href=\"http://github.com/petermichaux/royal-scheme\">http://github.com/petermichaux/royal-scheme</a></p>

<p>and I created a branch specifically for this integers-only version</p>

<p><a href=\"https://github.com/petermichaux/royal-scheme/tree/v0.1\">https://github.com/petermichaux/royal-scheme/tree/v0.1</a></p>

<p>You can get the code with the following command</p>

<pre><code>$ git clone https://github.com/petermichaux/royal-scheme.git</pre></code>

<p>You should be able to just run <code>make</code> and then the above REPL session example should work.</p>

<p>I&rsquo;m hoping you will scrutinize the code and really give me grief that I&rsquo;ve done something silly, stupid, overly complex, have a trailing space on a line, haven&rsquo;t written a comment where a comment would be helpful, etc. I&rsquo;m particularly interested in what you think of checking the return value of <code>printf</code> and <code>scm_write</code> in <code>repl</code>. It doesn&rsquo;t feel right quite to me. Also the overflow checking in <code>scm_read_number</code> happens each iteration which is not as efficient as it possibly could be.</p>

<p>By the way, registration for the <a href=\"http://scheme2011.ucombinator.org/\">Scheme 2011 Workshop</a> will open in August. I&rsquo;m planning on going and hoping to talk with some people there about Royal Scheme.</p>

<p>
  Previous article: <a href=\"/articles/scheme-from-scratch-royal-scheme-planning\">Introduction</a><br>
</p>

")) (entry nil (id nil "http://peter.michaux.ca/articles/javascript-is-dead-long-live-javascript") (title nil "JavaScript is Dead. Long Live JavaScript!") (updated nil "2011-06-25T20:21:00Z") (link ((href . "/articles/javascript-is-dead-long-live-javascript") (rel . "alternate") (type . "text/html"))) (content ((type . "html")) "<p>For 16 years, JavaScript has been the language of the web browser. This language has enabled the building of compelling web applications and contributed to the success of the web. Other scripting languages could have filled the role JavaScript does but JavaScript was in the right place at the right time. Microsoft added Basic to Internet Explorer a long time ago but JavaScript was the language in all the browsers and so it won. Since JavaScript has been cross-browser and at least good enough, the browser makers have not needed to add other language interpreters to the browsers themselves.</p>

<p>But we still didn&rsquo;t choose to use JavaScript. It has been the one option. It has powerful features like closures and we learned to love these features while turning a blind eye to the warty parts of the language. There has even been a lot of apologizing to the programming community along the lines of &ldquo;Yes we know it is a pretty funky language but please give it a chance. I&rsquo;m sure you&rsquo;ll learn to love it.&rdquo; It shouldn&rsquo;t be that hard to sell the quality of the language. JavaScript has been described as an experiment that escaped the lab a little too early and we&rsquo;ve been stuck with the warts ever since.</p>

<p>Still, JavaScript has been a great language. In 2007, Steve Yegge declared JavaScript as <a href=\"http://steve-yegge.blogspot.com/2007/02/next-big-language.html\">The Next Big Language</a> and it has been. Between then and now JavaScript-based web-applications have become bigger and better. With JavaScript&rsquo;s help, the web has continued to flourish even with the threat of native mobile apps taking over the same space.</p>

<p>In very recent times, JavaScript has been making its most successful attempt at being a server-side language. The Node.js platform, with its non-blocking I/O, may be solving a problem that programmers have needed solved for a long time. JavaScript is the language for Node.js and so JavaScript may go along for the ride to become a successful server-side language after many failed attempts in the past.</p>

<p>Overall, JavaScript has been a wild success. The most popular programming language in the world. But if the browser died today, how much new JavaScript code would be written tomorrow? Most likely JavaScript would become a fringe language overnight. But the browser isn&rsquo;t dying tomorrow. We will be programming for it for years to come.</p>

<p>As JavaScript has been used for more and larger programs, the warts of the language have become more apparent and caused increasing amounts of grief for many developers. It may come as a surprise that even though I&rsquo;ve written about JavaScript for years, I&rsquo;m not a JavaScript fanboy. Most of my JavaScript articles have been about me working through the difficulties of finding a peaceful coexistence with the language. Yes I&rsquo;ve enjoyed programming in JavaScript and have learned a lot but there certainly have been times when I&rsquo;ve felt like I&rsquo;m wallowing in the muck.</p>

<p>One of the most obvious deficiencies in JavaScript is with its user interface: its syntax. The inability to quickly improve its syntax has lead to the language&rsquo;s downfall.</p>


<h2>The Case for Syntax Extensions: Verbose Idioms</h2>

<p>Here we look at just four of the many examples where JavaScript&rsquo;s syntax could be improved to remove verbose idioms from our daily programming existences.</p>


<h3>Optional Parameters and Default Values</h3>

<p>JavaScript functions can be called with a variable number of actual parameters. This makes some of the formal parameters in the function&rsquo;s declaration optional. Often times these optional parameters must be set to a default value if no actual parameter is supplied. I&rsquo;m willing to bet you&rsquo;ve written and seen plenty of code like the following.</p>

<pre><code>function(a, b, option) {
    option = option || {};
    // ...
}</code></pre>

<p>I have and still write code like this. This code is wrong. If a falsy value is passed to the function for <code>option</code> then the wrong thing happens. We should be writing the following.</p>

<pre><code>function(a, b, option) {
    option = arguments.length &gt; 2 ? option : {};
    // ...
}</code></pre>

<p>Although this code expresses the intended thought of setting a default value if an actual parameter for <code>option</code> is not supplied, it is too verbose and less readable. The reader must count to determine which variable is has index 2. Beyond the awkwardness, the correct version is more difficult to maintain. It is easy to produce the following buggy code if the <code>b</code> parameter is removed.</p>

<pre><code>function(a, option) {
    option = arguments.length &gt; 2 ? option : {};
    // ...
}</code></pre>

<p>If your application uses optional parameters with default values, some new syntax would be beneficial for you.</p>

<pre><code>function(a, b, option = {}) {
    // ...
}</code></pre>

<p>The addition of this new syntax tunes the language better to your application&rsquo;s needs.</p>


<h3>Let</h3>

<p>Does the following buggy code look familiar?</p>

<pre><code>for (var i=0, ilen=elements.length; i&lt;ilen; i++) {
    var element = elements[i];
    LIB_addEventListener(element, 'click', function(event) {
        alert('I was originally number ' + i);
    });
}</code></pre>

<p>All the elements were the same number?! The solution is to use an immediately evaluated function expression so each alert reports a different number. This is the &ldquo;let&rdquo; idiom after Lisp&rsquo;s various <code>let</code> forms.</p>

<pre><code>for (var i=0, ilen=elements.length; i&lt;ilen; i++) {
    var element = elements[i];
    (function(num) {
        LIB_addEventListener(element, 'click', function(event) {
            alert('I was originally number ' + num);
        });
    }(i));
}</code></pre>

<p>Sure sometimes delegate listeners might be better than the above code but sometimes the above code is the desired idea. In the above case, we are trying to bind the order of the elements when the loop runs. This order could be lost with the delegate pattern if the elements are rearranged in the DOM.</p>

<p>This syntax is particularly awkward because of the distance between the formal <code>num</code> and actual <code>i</code> parameters of the immediate function.</p>

<p>The immediate function could be factored out to another location and called inside the loop.</p>
    
<pre><code>function attachListener(element, num) {
    LIB_addEventListener(element, 'click', function(event) {
        alert('I was originally number ' + num);
    });
}
for (var i=0, ilen=elements.length; i&lt;ilen; i++) {
    attachListener(elements[i], i);
}</code></pre>
   
<p>Even with this option, sometimes programmers still use the immediate function because it conveys better their intended message to readers.</p>  
 
<p>If your application uses the let idiom, wouldn&rsquo;t it be nice to have new syntax for it?</p>

<pre><code>for (var i=0, ilen=elements.length; i&lt;ilen; i++) {
    var element = elements[i];
    let (num = i) {
        LIB_addEventListener(element, function(event) {
            alert('I was originally number ' + num);
        });
    };
}</code></pre>

<p>With <code>num</code> and <code>i</code> together it is much easier to read this code and a new scope containing <code>new</code> has been introduced so the closure works properly. Once again, the addition of new syntax can tune the language better to your application&rsquo;s needs.</p>


<h3>Modules</h3>

<p>One of the most common idioms in JavaScript programs we all know and love is usually called &ldquo;the module pattern.&rdquo; This idiom provides the benefits of encapsulated variables that are private to the module and imparts sanity to our code.</p>

<pre><code>var event = (function() {

    // private variables
    var listeners = [];
   
    function addEventListener(f) {
        listeners.push(f);
    }

    function clearEventListeners() {
        listeners = [];
    }
    
    // ...
    
    // export the module's API
    return {
        addEventListener: addEventListener,
        clearEventListeners: clearEventListeners
        // ...
    };
}());</code></pre>

<p>The goal of encapsulation here isn&rsquo;t security. It is to ensure that other developers keep their dirty, monkey-patching hands off your module&rsquo;s data.</p>

<p>The exporting can be done a few ways but no matter which way there is some boiler plate.</p>

<p>Importing is verbose also</p>

<pre><code>(function() {

    // import desired properties of the event module
    var addEventListener = event.addEventListener;
    var clearEventListeners = event.clearEventListeners;
    
    // ...
}());</code></pre>

<p>Some new syntax would be nice to convey the intent of the module pattern better.</p>

<pre><code>module event {
    
    // private variables
    var listeners = [];
   
    export function addEventListener(f) {
        listeners.push(f);
    }

    export function clearEventListeners() {
        listeners = [];
    }
    
    // ...
}</code></pre>

<pre><code>(function() {

    import event;
    
    // ...
}());</code></pre>

<p>The module pattern is almost everywhere and some new syntax to better express this idiom would better tune the language to all of our applications.</p>


<h3>Inheritance</h3>

<p>These idiom examples have been growing in how they each span an increasing number of lines of code. The JavaScript idiom that potentially spans the most lines of your program may be the inheritance idiom.</p>

<pre><code>function Employee(first, last, position) {
    // call the superclass constructor
    Person.call(this, first, last);
    this.position = position;
};
// inherit from Person
Employee.prototype = Object.create(Person.prototype);
Employee.prototype.constructor = Employee;

// define an overridding toString() method
Employee.prototype.toString = function() {
    // call superclass's overridden toString() method
    return Person.prototype.toString.call(this) +
           ' is a ' + this.position;
};</code></pre>

<p>What a mess. Yes JavaScript makes single inheritance like this possible by linking prototypes but it takes a lot of code to manually make super things happen they way you might like inheritance to work.</p>

<p>If there could be a maintenance nightmare that is it. The strings &ldquo;Person&rdquo; and &ldquo;Employee&rdquo; are sprawled throughout the code for the Employee &ldquo;class&rdquo;.</p>

<p>If classes with inheritance are a big part of your application, some syntax would really help clean up the code. Perhaps something like the following.</p>

<pre><code>class Employee extends Person {
    constructor(first, last, position) {
        super(first, last);
        public position = position;
    }
 
    update(camera) {
        return super.update() + ' is a ' + position;
    }
}</code></pre>

<p>That is a major improvement.</p>


<h3>Learning from Idioms</h3>

<p>These common idioms make it clear that JavaScript could use some new syntax for several reasons. The ability to do what we want is usually in JavaScript somewhere. The verbosity of the idioms is sometimes too much. We cut corners. Sometimes we avoid certain algorithms because the idioms are too verbose. The idioms are not self explanatory. They are inside secrets of the community and the intent is not easily recognized by outsiders.</p>

<p>The ECMAScript committee has recognized that the above idioms, and others idioms, are common across a wide variety of applications. There are proposals for all of these syntax cases in Harmony. Some of them may make it into the next version of ECMAScript and into the browsers for your use. If new syntax gets there eventually then you can use use it.</p>

<p>Idioms may have emerged in <em>your</em> application that do not appear in a wide variety of applications. For example, Node.js&rsquo;s non-blocking I/O and heavy reliance on callbacks will undoubtedly result in idioms that do not appear in browser scripts. Syntax specific to just your applications will likely never make it into ECMAScript.</p>

<p>If you would like to use specialized syntax for the general idioms like those shown above or you would like syntax for your own idioms, what can you do?</p>


<h2>If Only We Had Macros</h2>

<p>Lisp languages have had full-blown macros for decades. Through macros, Lisp gives programmers the ability to tune the language&rsquo;s syntax to best match their own applications. Because of its macros, Lisp has been described as &ldquo;the programmable programming language.&rdquo; Powerful stuff.</p>

<p>Lisp&rsquo;s s-expression syntax, you know, the syntax with all those parens, gives the language a special property called homoiconicity. It roughly means the syntax of the language is also the syntax of its data structures or that a program&rsquo;s parse tree uses the languages data structures. This homoiconicity makes Lisp&rsquo;s macros possible.</p>

<p>JavaScript doesn&rsquo;t have macros. A major reason for this is that adding macros to languages with C-like syntax, languages that are not homoiconic, is still a research topic. Excerpts from a short conversation on Twitter with littlecalculist, Dave Herman, Ph.D., ECMAScript committee member, and Mozilla Researcher:</p>

<blockquote>
    <dl>
        <dt>@petermichaux</dt>
        <dd>I believe @littlecalculist knows more about the research and possibilities for macros in ECMAScript. I&rsquo;d like to know more also.</dd>
        
        <dt>@littlecalculist<dt>
        <dd>I have thoughts on it for sure. But macros for non-sexp languages is still very much a challenging research topic</dd>

        <dt>@petermichaux<dt>
        <dd>[...] We&rsquo;ll turn blue waiting for macros.</dd>

        <dt>@littlecalculist<dt>
        <dd>Might I suggest you keep breathing? ;-) Seriously, I do hope to try, but trust me, macro system design is hard.</dd>
    </dl>
</blockquote>

<p>The message is pretty clear. JavaScript macros are not just around the corner.</p>


<h2>Harmony Syntax ETA</h2>

<p>Perhaps the syntax extensions in Harmony are all you dream of and more. If Harmony becomes ECMAScript&nbsp;6 and ECMAScript&nbsp;6 becomes ubiquitous then you&rsquo;ll be all set. So all you need to do is wait...patiently.</p>

<p>First, let&rsquo;s look at browser adoption. Unfortunately I&rsquo;ll pick on Internet Explorer a bit, which has almost become a cliche, but not because I have something against the Internet Explorer development team at Microsoft or the newest versions of Internet Explorer. It is necessary to look at this browser because it is perhaps the most important case study for estimating when features will be available for all visitors to your web site.</p>

<p>As of May 2011, <a href=\"http://www.w3schools.com/browsers/browsers_stats.asp\">w3schools</a>, which has relatively tech-savvy visitors, reports Internet Explorer&nbsp;6 still has 2.4% market share. <a href=\"http://marketshare.hitslink.com/browser-market-share.aspx?spider=1&amp;qprid=2\">Net Market Share</a> reports Internet Explorer&nbsp;6 still has 10.36% market share. Your site probably has a market share somewhere between those two numbers but this browser is still hanging on even though it was superseded by Internet Explorer&nbsp;7 in November 2006. How many people are still using Internet Explorer&nbsp;6 or 7? The w3schools site shows 7.7% and Net Market Share shows 18.2%. These browsers just aren&rsquo;t going away fast enough. A publicly available site (e.g. Amazon) cannot afford to ignore market share numbers this large.</p>
    
<p>There is no point in spending any energy moaning that users should upgrade their browsers or that &ldquo;IE should die!&rdquo; It won&rsquo;t happen. I don&rsquo;t know if it is true but someone once said to me &ldquo;Internet Explorer users upgrade their browser when they upgrade their hardware.&rdquo; For the past few years, hardware has certainly become sufficient that people don&rsquo;t need to upgrade anything to use email, Facebook, Twitter, etc.</p>

<p>Suppose your web app is sufficiently advanced that you&rsquo;ve decided that you only care about users with &ldquo;modern&rdquo; browsers. Google Apps recently announced that on August 1, 2011 they will stop supporting Internet Explorer&nbsp;7. That is almost 5 years after Internet Explorer&nbsp;7 was released.</p>
    
<p>Now think about this: Internet Explorer&nbsp;10 is not out yet but, of course, even it won&rsquo;t have Harmony&rsquo;s syntax extensions. Let&rsquo;s estimate that Harmony is approved as ECMAScript&nbsp;6 in mid-2012 and Internet Explorer&nbsp;11 is released in early 2013 with support for all of Harmony&rsquo;s syntax. Five years after that, in 2018, the Google Apps team can drop support for Internet Explorer&nbsp;11 and finally use Harmony syntax freely. (On August 1, 2011, they are also dropping support for the four-year-old Safari&nbsp;3 and two-year-old Firefox&nbsp;3.5 so the waits are still long-ish for other browsers too.)</p>

<p>Amazon developers might need to wait an additional 5&nbsp;years before they can use Harmony syntax. That&rsquo;s 2023!</p>

<p>Will you be satisfied waiting 7-12&nbsp;years before you can start using syntax that would be helpful developing your web apps today? Being more optimistic, even if the wait is just 5&nbsp;years, will you wait?</p>


<h2>JavaScript is Dead.</h2>

<p>Cause of death: semicolon cancer.</p>

<p>Perhaps due to JavaScript&rsquo;s syntax alone, JavaScript does not have macros now and won&rsquo;t have them soon if ever. Millions of programmers use JavaScript now and plenty of them are tired or tiring of the verbose idioms confronting them daily. They want new syntax now and won&rsquo;t wait. For this growing group of developers, JavaScript the source code language is dead.</p>

<p>You had a good reign, JavaScript. We had some good times and wrote some cool apps together. May you rest in peace.</p>


<h2>Long Live JavaScript!</h2>

<p>Programmers like to control their own destiny and they are taking action. You can have all the new syntax you want for your browser scripts, right now, if you write in another source language and compile to the ECMAScript&nbsp;3 dialect of JavaScript for the billions of browsers in the wild. By compiling to ECMAScript&nbsp;3 you are completely freed from JavaScript&rsquo;s syntactic evolution. As an added bonus, you can even <em>fix</em> some of JavaScript&rsquo;s semantic gotchas with a sufficiently sophisticated compiler. JavaScript&rsquo;s new life is as a compilation target.</p>


<h2>Languages that Compile to JavaScript</h2>

<p>There have been compilers to JavaScript for years now. In 2007, I started collecting a list of languages with compilers to JavaScript. There were JavaScript extension languages: the now-defunct ECMAScript&nbsp;4, Narrative JavaScript, and Objective-J. There were pre-existing languages: Scheme, Common Lisp, Smalltalk, Ruby, Python, Java, C#, Haskell, etc. There were even brand new languages HaXe, Milescript, Links, Flapjax that were designed to address web programming needs.</p>

<p>Of these compiler projects, Google&rsquo;s GWT Java-to-JavaScript compiler has probably been the most successful but I don&rsquo;t see programmers who first learned a language other than Java rushing to use Java as their source code language. In fact, none of these compiler projects have accrued a significant long-term user base. At least in the parts of the web that I frequent, with the exception of GWT, it is rare to read about programmers using these compilers for any real projects. There are several legitimate reasons not to use one of these compilers.</p>

<p>Imagine you build a big project using one of these compilers and part way through find a bug in the compiler. The one maintainer of the compiler may have lost interest or time. Do you want to maintain a compiler? Does anyone on your team have the skills to do that? That ulcer is going to get pretty big while you prepare to explain to the CEO that you now need to rewrite the UI in JavaScript.</p>

<p>Just the thought of debugging compiled code when a production bug is filed makes my stomach churn. Core dump. What line number in the source code matches the line number Firebug is reporting for the compiled code? HURRY! That bug needs to be fixed now!!!!</p>

<p>You&rsquo;ve used Objective-J for a big project and now you need to hire a new good programmer. What are your chances of finding the right person? They are probably very low. Just finding an available JavaScript programmer is difficult enough. If you use one of these alternate languages, it is very likely you&rsquo;ll need to train each new person you add to your team.</p>

<p>Even without these compiler projects being wildly successful, the list of languages that compile to JavaScript has continued to grow. There is no doubt that writing a to-JavaScript compiler is a very cool project. Please pay me to write one.</p>

<p>There is one notable new entry in the list of languages that compile to JavaScript that is actually causing a big stir and is possibly changing the game for good.</p>


<h3>CoffeeScript</h3>

<p>I can tell you right now, I don&rsquo;t know why CoffeeScript has the magic combination of features to garner the attention it has when other projects have failed. Significant whitespace and arrow function syntax. My gut reaction is yuck. There is plenty of things to like: default parameter values, rest parameters, spread, destructuring, fixing the whole implied global mess, even classes if you&rsquo;re into that kind of thing and more. Many of CoffeeScript&rsquo;s features are part of Harmony and so may be in browsers sometime in the future but if you use CoffeeScript then you can have them now. There is nothing like instant gratification.</p>

<p>Programmers are bursting with affection for CoffeeScript.</p>

<blockquote>
    <dl>
        <dt>@pyronicide</dt>
        <dd>Being able to use default values for function arguments in #coffeescript makes me immensely happy.</dd>
    </dl>
</blockquote>

<blockquote>
    <dl>
        <dt>@_jdpage</dt>
        <dd>CoffeeScript is wonderful. Now I am spoiled and will complain whenever I have to write JavaScript instead.</dd>
    </dl>
</blockquote>

<p>At the TXJS 2011 conference, Douglas Crockford apparently shared that he thinks &ldquo;CoffeeScript is clearly good stuff.&rdquo;</p>

<p>There is one aspect of the CoffeeScript project that I really like and it is summed up by the following two quotations. The first comes from Trevor Burnham, author of <a href=\"http://pragprog.com/titles/tbcoffee/coffeescript\">CoffeeScript: Accelerated JavaScript Development</a>.</p>

<blockquote>
    <dl>
        <dt>@trevorburnham</dt>
        <dd>[...] It&rsquo;s not about turning JS into Ruby/Python; it&rsquo;s about having a syntax better suited to JavaScript&rsquo;s inner goodness.</dd>
    </dl>
</blockquote>

<p>The second is from <a href=\"http://arcturo.com/library/coffeescript/00_introduction.html\">The Little Book on CoffeeScript</a>.</p>

<blockquote>
    <p>CoffeeScript neatly sidesteps these [JavaScript issues], by only exposing a curated selection of JavaScript features.</p>
</blockquote>

<p>The attitude expressed in these quotations really is great and genius marketing too. It is not CoffeeScript verse JavaScript. It is CoffeeScript enhancing the JavaScript programming experience. Could some different syntax and a restricted subset of JavaScript&rsquo;s features really be better than plain old JavaScript?</p>

<p>Douglas Crockford seems to think so. For years, his <a href=\"http://jslint.com/\">JSLint</a> has been hurting our feelings and demanding that we use very specific whitespace and syntax and that we avoid dangerous JavaScript features. Source code that passes JSLint has access to a true subset of JavaScript: the subset that he calls &ldquo;the good parts.&rdquo; This dialect of JavaScript deserves a name. Maybe GoodScript? After all, you are only allowed to use JSLint for good and not for evil.</p>

<p>The ECMAScript committee also thinks this is a good idea. The <code>\"use strict\"</code> pragma introduced in ECMAScript&nbsp;5 not only restricts some language features like <code>with</code>, strict mode even changes/fixes the semantics of some parts of the language. Because of the semantic changes, ECMAScript&nbsp;5 strict is a different language or at least a different dialect than ECMAScript&nbsp;5 non-strict.</p>

<p>CoffeeScript, GoodScript, and ECMAScript&nbsp;5 strict share common goals of keeping you away from the dangerous parts of JavaScript while giving you access to the valuable, safe parts. Each enforces these goals differently but they are enforced one way or another. You don&rsquo;t get new syntax with GoodScript. It is already JavaScript and ready for the browser. You don&rsquo;t get to use ECMAScript&nbsp;5 strict because it is not available in all browsers yet and won&rsquo;t be for years.</p>

<p>So CoffeeScript seems to be targeting a particular need of web development and maybe that is something other to-JavaScript compilers haven&rsquo;t done or haven&rsquo;t done well before.</p>

<p>CoffeeScript is also a reasonably thin skin over JavaScript. One consequence of this is that the compiled JavaScript code is reasonably easy to read and not brutal to debug (so I&rsquo;m told.) This reduced debugging fear is contributing to interest in CoffeeScript.</p>

<p>CoffeeScript almost feels like a set of macros for writing JavaScript programs.</p>

<p>Since CoffeeScript compilers are in the hands of developers rather than the visitors to sites, you control which version of CoffeeScript you are using. You can upgrade at will. This also means CoffeeScript does not need to be standardized and go through the subsequent painfully slow growth of a standardized language. CoffeeScript can grow at the rate of its community&rsquo;s imagination and desire. JavaScript standardization was essential to the success of the web but the same constraints do not apply to CoffeeScript.</p>


<h2>Well then I&rsquo;m going to invent my own language.</h2>

<p>You can do this and it would be a great exercise. You&rsquo;ll be able to call yourself a compiler writer which is pretty darned prestigious.</p>

<p>The danger of inventing your own language lies in the thinking that you can do better than JavaScript has done <strong>in the long run</strong>. Language design is hard and I bet your language will grow its share of unsightly hairs. Maybe not as many hairs as JavaScript but still. CoffeeScript hasn&rsquo;t hit puberty yet but there are already signs that hair follicles may exist.</p>

<blockquote>
    <dl>
        <dt>@maxsamukha</dt>
        <dd>CoffeeScript: The way variables in outer scopes can be accidentally overwritten is fishy. How bad is it in practice?</dd>
    </dl>
</blockquote>

<p>You were so proud that your simple, readable compiled code was easy to debug. That will become harder as you realize the compiled code&rsquo;s semantics aren&rsquo;t quite what they were supposed to be in corner cases.</p>
    
<p>Idioms will appear in your language and someone will fork your compiler to do away with those idioms (unless your language happens to have macros.)</p>

<p>Enough with this nay saying. Go and write your own language right now. You&rsquo;ll be a better programmer for it.</p>


<h2>What&rsquo;s missing from JavaScript the target language?</h2>

<p>JavaScript is embarking on a new life as a compilation target. It is a capable target for many language features but it could use improvement. In his <a href=\"http://brendaneich.com/2011/05/my-jsconf-us-presentation/\">JSConf.US talk</a>, Brendan Eich stated that one the goals for Harmony is to be a better target for to-JavaScript compilers.</p>

<p>Compiled JavaScript can run slower than hand-written JavaScript just like compiled C can be slower than hand-written Assembly (though not always.) Some inefficiency in compiled JavaScript is tolerable because JavaScript virtual machines are fast and the DOM is the bottleneck anyway. That said, some potential source code languages have semantics sufficiently far from JavaScript&rsquo;s semantics that the compiled code is so inefficient that it cannot realistically be used in production web apps. There are already features in Harmony that will enable some of these languages to be compiled to efficient code and thus make these viable source code languages.</p>


<h3>Proper Tail Calls</h3>

<p>Programs in Lisp languages depend heavily on recursive calls to properly tail recursive procedures. The <a href=\"http://wiki.ecmascript.org/doku.php?id=harmony:proper_tail_calls&amp;s=const\">proper tail calls</a> proposal in Harmony will allow these programs to be compiled to JavaScript without the inefficient trampoline technique currently necessary to avoid overflowing the call stack. Awesome! Let&rsquo;s look at that in a bit more detail.</p>

<p>The following JavaScript is an example of mutually recursive functions which would work fine in Lisp but since JavaScript currently does not have proper tail calls, will overflow the JavaScript call stack when <code>number</code> is large.</p>

<pre><code>function isEven(number) {
    if (number === 0) {
        return true;
    }
    else {
        return isOdd(number - 1);
    }
}

function isOdd(number) {
    if (number === 0) {
        return false;
    }
    else {
        return isEven(number - 1);
    }
}

isEven(100000); // InternalError: too much recursion</code></pre>

<p>In the above code, a call to <code>isEven(100000)</code> isn&rsquo;t complete and removed from the call stack until <code>isOdd(99999)</code> returns which isn&rsquo;t complete and removed from the call stack until <code>isEven(99998)</code> returns and so on. That&rsquo;s a lot of calls on the call stack! And there is no need for them all to be on the call stack. <code>isEven(100000)</code> doesn&rsquo;t have anything intelligent remaining to do once it calls <code>isOdd(99999)</code> because the call to <code>isOdd(99999)</code> is the very last thing in <code>isEven(100000)</code>. The call is said to be in tail position. <code>isEven(100000)</code> is just waiting to return the value returned by <code>isOdd(99999)</code> and a clever language can just pop <code>isEven(100000)</code> off the call stack and replace it with the call to <code>isOdd(99999)</code> thus saving space on the call stack.</p> 

<p>With trampolines we can ensure that even in JavaScript the call stack doesn&rsquo;t grow large. The following is just a sketch of how trampolines might be implemented and how <code>isEven</code> and <code>isOdd</code> might be compiled for a JavaScript interpreter that doesn&rsquo;t have proper tail calls.</p>

<pre><code>function bounce(ret) {
    while (typeof ret === 'function') {
        ret = ret();
    }
    return ret;
}

function isEven(number) {
    if (number === 0) {
        return true;
    }
    else {
        return function() {
            return isOdd(number - 1);
        };
    }
}

function isOdd(number) {
    if (number === 0) {
        return false;
    }
    else {
        return function() {
            return isEven(number - 1);
        };
    }
}

bounce(function() {return isEven(100000);}); // true</code></pre>

<p>You can see the extra overhead of the <code>bounce</code> function which implements the trampoline calls is quite onerous. It creates closures for each continuation, doubles the number of calls, and must examine the returned value after each bounce; however, <code>isEven(10000)</code> does complete and is removed from the callstack <em>before</em> <code>isOdd(99999)</code> is called. The full computation completes in constant call stack space.</p>

<p>The bottom line is trampolines incur too much overhead. They incur so much overhead that when Rich Hickey created Clojure, his Lisp for the JVM, he decided his language could not have proper tail calls because trampolines were too expensive. That must have been a painful decision for someone who loves the Lisp family of languages.</p>

<p>The good news is that the ECMAScript committee has recognized this deficiency in JavaScript and has added proper tail calls to Harmony. This will benefit programmers writing directly in JavaScript and developers of to-JavaScript compilers.</p>


<h3>Lambdas</h3>

<p>Another strawman proposal not yet promoted to Harmony is the <a href=\"http://wiki.ecmascript.org/doku.php?id=strawman:block_lambda_revival\">Block Lambda Revival</a> which combines some new syntax with a new language construct called a lambda. A lambda is a callable thing, like a function, but it obeys Tennent&rsquo;s Correspondence Principle. Tennent&rsquo;s Correspondence Principle states that wrapping an expression or block of code in an immediate lambda should not change the meaning of that wrapped code. JavaScript functions are not lambdas and do not obey Tennent&rsquo;s Correspondence Principle. For example,</p>

<pre><code>function one() {
    return 1;
}

one(); // 1</code></pre>

<p>is not the same when the return line is wrapped in an immediate function</p>

<pre><code>function one() {
    (function() {
        return 1;
    }());
}

one(); // undefined</code></pre>

<p>The syntax of the block lambda proposal for a lambda that takes two arguments and sums them is <code>{|a,&nbsp;b|&nbsp;a&nbsp;+&nbsp;b}</code></p>

<p>Using the syntax of the block lambda proposal  we can wrap the return line in an immediate lambda without changing the meaning.</p>

<pre><code>function one() {
    ({||
        return 1;
    }());
}

one(); // 1</code></pre>

<p>Thanks to lambdas obeying Tennent&rsquo;s Correspondence Principle, the <code>return</code> still means return from the function <code>one</code>.</p>

<p>You may ask &ldquo;Who cares about this computer science-y stuff?&rdquo; to which I reply &ldquo;Did any of that macro business seem useful?&rdquo; because lambdas are a fundamental building block in the code generated by many macros. And since lambdas play nicely with JavaScript&rsquo;s <code>return</code>, <code>arguments</code>, and <code>this</code>, lambdas would be a valuable addition to the language for compiler writers.</p>

<p>I&rsquo;m focusing on the JavaScript-as-a-target aspect of the block lambda proposal. If you plan on writing in JavaScript forever after, the proposal has other benefits for you too that don&rsquo;t matter to compiler writers.</p>

<p>The block lambda strawman has not yet been promoted to Harmony and so currently doesn&rsquo;t have a path into ECMAScript&nbsp;6 and browsers around the world. The standardization process is slow. Maybe there will be another decade stall in evolving the language like there was after ECMAScript&nbsp;3. Maybe the next edition of ECMAScript will be the last edition. Better to get the best stuff in there than hope to get it in later. If you care about the future of JavaScript and think lambdas would be a benefit to the language then <strong>let the ECMAScript committee know by sending a message to the <a href=\"https://mail.mozilla.org/listinfo/es-discuss\">es-discuss mailing list</a> in support of the block lambda proposal</strong>. Powerful, orthogonal language features like tail calls and lambdas which have no efficient workarounds may be the most important additions in the next edition of ECMAScript.</p>


<h2>What&rsquo;s missing from the browser?</h2>

<p>The browser can help JavaScript succeed in its new life as a compilation target. The browser interprets compiled JavaScript and complains when the compiled code has an error. The error messages contain line numbers in the compiled code but you want to know the line number in source code.</p>

<p>The Mozilla crowd has <a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=618650\">an open ticket</a> and <a href=\"https://wiki.mozilla.org/DevTools/Features/SourceMap\">a dev tools project</a> to ease debugging source code by mapping compiled code lines to source code lines. Since you control the browser in which you primarily develop and test, you can use this feature as soon as it is ready.</p>

<p>Somewhere I read that the Webkit folks are developing similar source code debugging assistance but I cannot find any concrete evidence.</p>


<h2>Polyglot</h2>

<p>JavaScript&rsquo;s monopoly in the browser has meant front-end programmers all speak the same language. This has given the community a <i>lingua franca</i> enabling good communication and code sharing. We are now headed for a polyglot future where you choose the language(s) you want to learn and use for developing browser applications. Maybe you are only using a few JavaScript language extensions via <a href=\"http://code.google.com/p/traceur-compiler/\">Traceur</a> and compiling templates to JavaScript with <a href=\"http://mustache.github.com/\">Mustache</a>. This still means that the CoffeeScript programmer won&rsquo;t understand your source code immediately.</p>

<p>This divergence was inevitable as it has happened on all previously successful platforms. There have been multiple languages for building native applications almost forever. C is still common but C++, Objective-C, and many other languages are available. The JVM was intended to run programs written in Java but clever developers have added other languages like Clojure and JRuby as options. Microsoft recognized what seems to be a human psychological need for a variety of languages and developed its .NET CLR platform for multiple languages from the beginning. Programs written in Basic, C#, IronPython, etc can all be run on the CLR.</p>

<p>Barriors to communication in the front-end community are not new anyway. A developer using Dojo cannot immediately understand the source code of an application written with jQuery or YUI. There is a plethora of libraries, some very different, that add the ideas of class-based inheritance to JavaScript. So we already have our barriors even within JavaScript.</p>

<p>Having multiple source languages will increase the barriers in our community. Programmers will still need to know JavaScript, at least for a while, but in a few years they may know other source languages better then they know JavaScript.</p>

<p>Choice is a blessing and a curse.</p>


<h2>Summary</h2>

<p>It is great having the opportunity to watch JavaScript&rsquo;s transition to a new life as it happens. It&rsquo;s impossible to say which languages will end up winning market share in the to-JavaScript compilation but it is sure to be interesting. CoffeeScript is gaining momentum now but I think many other successful source code languages will follow.</p>

<p>What do you think will happen?</p>


")) (entry nil (id nil "http://peter.michaux.ca/articles/sicp-classes-for-javascript") (title nil "SICP Classes for JavaScript") (updated nil "2011-06-05T11:56:00Z") (link ((href . "/articles/sicp-classes-for-javascript") (rel . "alternate") (type . "text/html"))) (content ((type . "html")) "<p><strong>Warning:</strong> This article is intended for JavaScript programmers. Parens are coming but only briefly and you can handle it and it will be good for you.</p>

<p>In <strong>Structure and Interpretation of Programming Languages Second Edition</strong> (SICP) on page 182, the authors introduce the idea of <i>message passing</i> with the following example in Scheme of a complex number constructor function.</p>

<pre><code>(define (make-from-real-imag x y)
  (define (dispatch op)
    (cond ((eq? op 'real-part) x)
          ((eq? op 'imag-part) y)
          ((eq? op 'magnitude)
           (sqrt (+ (square x) (square y))))
          ((eq? op 'angle) (atan y x))
          (else
           (error \"Uknown op -- MAKE-FROM-REAL-IMAG\" op))))
  dispatch)</code></pre>

<p>The important part to note here is that the value returned by the <code>make-from-real-imag</code> constructor function is actually a dispatch procedure that you can call with a message argument. You can send messages to get the real part or magnitude of the complex number.</p>

<pre><code>(define c (make-from-real-imag 3 4))
(c 'real-part) ; 3
(c 'imag-part) ; 4
(c 'magnitude) ; 5
(c 'angle)     ; 0.927295218001612
(c 'asdf)      ; ERROR: Uknown op -- MAKE-FROM-REAL-IMAG: asdf</code></pre>


<p>Let&rsquo;s see what the above code looks like in JavaScript, our <i>lingua franca</i>.</p>

<pre><code>function makeFromRealImag(x, y) {
    function dispatch(op) {
        switch (op) {
            case 'realPart': return x;
            case 'imagPart': return y;
            case 'magnitude':
                return Math.sqrt(x*x + y*y);
            case 'angle': return Math.atan2(y, x);
            default:
                throw 'Unknown op -- makeFromRealImag: ' + op;
        }
    }
    return dispatch;
}

var c = makeFromRealImag(3, 4);
c('realPart');  // 3
c('imagPart');  // 4
c('magnitude'); // 5
c('angle');     // 0.9272952180016122
c('asdf');      // \"Unknown op -- makeFromRealImag: asdf\"</code></pre>

<p>Now this probably doesn&rsquo;t look like any object-oriented JavaScript you&rsquo;ve seen before but it illustrates an important point. In JavaScript, we can represent the idea of an object as a function of its messages. The constructor function returns a dispatch function that you wrote that can dispatch any message any way that you want it to. This immediately gives you Spidermonkey&rsquo;s <code>__nosuchmethod__</code>, Smalltalk&rsquo;s <code>doesNotUnderstand</code>, and Ruby&rsquo;s <code>method_missing</code>. Powerful stuff but unfortunately the JavaScript code above runs very slowly. We can move towards a faster and more familiar JavaScript style.</p>

<p>SICP page 223, introduces the idea of mutable objects but the most interesting point is the variation on the dispatch procedure.</p>

<pre><code>(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        \"Insufficient funds\"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (error \"Unknown request -- MAKE-ACCOUNT\"
                       m))))
  dispatch)

(define account (make-account 10))
((account 'deposit) 5)  ; 15
((account 'withdraw) 3) ; 12</code></pre>

<p>Converting this to JavaScript we have the following.</p>

<pre><code>function makeAccount(balance) {
    function withdraw(amount) {
        if (balance >= amount) {
            balance = balance - amount;
            return balance;
        }
        return \"Insufficient funds\";
    }
    function deposit(amount) {
        balance = balance + amount;
        return balance;
    }
    function dispatch(m) {
        switch (m) {
            case 'withdraw': return withdraw;
            case 'deposit': return deposit;
            default:
                throw \"Unknown request -- makeAccount: \" + m;
        }
    }
    return dispatch;
}

var account = makeAccount(10);
account('deposit')(5);  // 15
account('withdraw')(3); // 12</code></pre>

<p>The way the <code>dispatch</code> function works for accounts is quite different than in the complex numbers case. In the case of complex numbers, when a message was sent to the <code>dispatch</code> function, it executed the associated operation (i.e. the method) immediately. In contrast, the account <code>dispatch</code> function returns the method associated with the message and that method can then be called.</p>

<p>This is very similar to how JavaScript&rsquo;s <code>reciever.message(arg)</code> syntax works and we can move to a more familiar object-oriented JavaScript style.</p>

<pre><code>function makeAccount(balance) {
    function withdraw(amount) {
        if (balance >= amount) {
            balance = balance - amount;
            return balance;
        }
        return \"Insufficient funds\";
    }
    function deposit(amount) {
        balance = balance + amount;
        return balance;
    }
    return {
      withdraw: withdraw,
      deposit: deposit
    };
}

var account = makeAccount(10);
account.deposit(5);  // 15
account.withdraw(3); // 12</code></pre>

<p>In this last version, we&rsquo;ve stopped writing our own dispatch logic and use JavaScript&rsquo;s built-in property lookup. This increases speed significantly. We&rsquo;ve lost the ability to do the <code>__noSuchMethod__</code> type of dispatching when using standard ECMAScript but that doesn&rsquo;t seem to be commonly useful anyway.</p>

<p>For the well-read JavaScript programmers out there, you may recognize this last version as <i>durable objects</i> from Douglas Crockford&rsquo;s book <strong>JavaScript: The Good Parts</strong>.</p>

<p>I find it interesting that the word &ldquo;inheritance&rdquo; does not appear in SICP&rsquo;s index even though the book goes on to implement complex programs like language interpreters and compilers in a message passing style. That shows this simple style of object-oriented programming can take you far.</p>

<p>The moral of the story is that old books are worth reading and can change the way you program today. You can even <a href=\"http://mitpress.mit.edu/sicp/\">read SICP for free</a>.</p>


")) (entry nil (id nil "http://peter.michaux.ca/articles/now-with-tweets") (title nil "Now with Tweets") (updated nil "2011-05-28T20:01:00Z") (link ((href . "/articles/now-with-tweets") (rel . "alternate") (type . "text/html"))) (content ((type . "html")) "<p>I'm giving Twitter a try. If you <a href=\"http://twitter.com/petermichaux\">follow me</a> then you can watch the experiment unfold.</p>
")))) ("Early Mixins, Late Mixins" "<p>In JavaScript, the language supplies us with several code reuse patterns. Prototype chaining gives us the primary single inheritance mechanism. Mixins are also an important pattern when we want one object to &ldquo;inherit&rdquo; functionality from multiple objects. There are several ways to implement the mixin process. This article looks at two contrasting implementations: early mixins and late mixins.</p>
<h2>Late Binding</h2>
<p>Let&rsquo;s start with a quick review of what late binding gives us.</p>
<pre><code>var adam = {
greet: function() {
return \"hello\";
}
};
adam.greet(); // \"hello\"</code></pre>
<p>When we ask <code>adam</code> to <code>greet</code>, the method to be executed is looked up at the time of the call. This is late binding and means if we redefine the greet method, subsequent calls will use the new definition.</p>
<pre><code>adam.greet = function(name) {
return \"hello\" + (name ? (\", \" + name) : \"\");
};
adam.greet(\"world\"); // \"hello, world\";</code></pre>
<p>This ability to redefine a method is valuable because it makes it possible for plugins to modify the behaviour of an existing code library.</p>
<h2>Late Binding and Prototype Chaining</h2>
<p>How does late binding work with prototype chaining? Let&rsquo;s start with a fresh example. First we&rsquo;ll make a new object <code>adam</code> who introduces himself.</p>
<pre><code>var adam = {
_name: \"Adam\";
greet: function() {
return \"hello. I am \" + this._name;
}
};</code></pre>
<p>Someone named Adam seems like a suitable prototype for all existing people. We can make a constructor function to produce more people.</p>
<pre><code>function Person(name) {
this._name = name;
}
Person.prototype = adam;
var eve = new Person(\"Eve\");
eve.greet(); // \"hello. I am Eve\"</code></pre>
<p>Thanks to the combination of late binding and the prototype chain, a change to <code>adam</code> will result in a change to <code>eve</code> instantly. The following could be some plugin for the library that provides the <code>adam</code> object. This redefinition could happen at runtime due to user interaction.</p>
<pre><code>adam.greet = function(name) {
return \"hello\" + (name ? (\", \" + name) : '') + \". I am \" + this._name;
};
eve.greet(\"world\"); // \"hello, world. I am Eve\"</code></pre>
<h2>Early Mixins</h2>
<p>Another way to create a reusable bunch of code as a library is to provide one object who&rsquo;s properties can be mixed into another object. This is usually done with an early mixin implementation.</p>
<p>First, a generic function that can mix properties from one object into another object.</p>
<pre><code>function earlyMixin(sink, source) {
for (var property in source) {
sink[property] = source[property];
}
}</code></pre>
<p>Now a object containing methods that would be useful on another object. Here is a library called Speeches.JS.</p>
<pre><code>var speeches = {
greet: function() {
return \"hello. I am \" + this._name;
},
farewell: function() {
return \"goodbye. I am \" + this._name;
}
};</code></pre>
<p>Since this Speeches.JS library is already written and well unit tested, we&rsquo;d like to reuse that code in our code.</p>
<pre><code>function Person(name) {
this._name = name;
}
earlyMixin(Person.prototype, speeches);
var adam = new Person('Adam');
adam.greet(); // \"hello. I am Adam\"</code></pre>
<p>Now suppose we have mixed this <code>speeches</code> object into several other objects (like the <code>Person.prototype</code> object.) Also suppose we want to modify the <code>speeches</code> object at some later time and have all objects who&rsquo;ve had the <code>speeches</code> object mixed into it be updated. This is what a plugin for Speeches.JS might want to do.</p>
<pre><code>speeches.greet = function(name) {
return \"hello\" + (name ? (\", \" + name) : '') + \". I am \" + this._name;
};</code></pre>
<p>Unfortunately we cannot do this because the <code>speeches</code> methods have been mixed into the <code>Person.prototype</code> object early (i.e. at the time of mixin.) We still have</p>
<pre><code>adam.greet(\"world\"); // \"hello. I am Adam\"</code></pre>
<h2>Late Mixins</h2>
<p>In order to make it possible to modify <code>speeches</code> and have all objects use the modified methods, we need one level of indirection in the mixin process.</p>
<pre><code>function lateMixin(sink, source) {
for (var property in source) {
(function(property) {
sink[property] = function() {
return source[property].apply(this, arguments);
}
}(property));
}
}</code></pre>
<p>Instead of directly borrowing the methods of the <code>source</code>, the <code>sink</code> is given methods that call the methods of <code>source</code>. This means that the method on <code>source</code> are mixed in late because they are looked up when they are called (rather than when they are mixed in.)</p>
<p>Now we can go through the same example with a different result.</p>
<pre><code>var speeches = {
greet: function() {
return \"hello. I am \" + this._name;
},
farewell: function() {
return \"goodbye. I am \" + this._name;
}
};
function Person(name) {
this._name = name;
}
lateMixin(Person.prototype, speeches);
var adam = new Person('Adam');
adam.greet(); // \"hello. I am Adam\"
speeches.greet = function(name) {
return \"hello\" + (name ? (\", \" + name) : '') + \". I am \" + this._name;
};
adam.greet(\"world\"); // \"hello, world. I am Adam\"</code></pre>
<p>When <code>adam.greet</code> is called it uses the most recent definition of <code>speeches.greet</code>. Yay! Late mixins have given us the same dynamic power that late binding and the prototype chain give us. This makes a library like Speeches.JS more flexible and opens it up for various kinds of modification at run time.</p>
<h2>Not Quite Everything</h2>
<p>Late mixins give us some of the power of late binding and the prototype chain but not everything. If we add another method to the <code>speeches</code> object it is not added to the other objects into which <code>speeches</code> has been mixed. There are several ways to accomplish this type of functionality. Something like <a href=\"http://wiki.ecmascript.org/doku.php?id=harmony%3adirect_proxies\" target=\"_blank\">proxies</a> might be our answer to get closer to real multiple inheritance.</p>" "/articles/early-mixins-late-mixins" (20619 6636) old 1 nil nil ((id nil "http://peter.michaux.ca/articles/early-mixins-late-mixins") (title nil "Early Mixins, Late Mixins") (updated nil "2012-10-26T23:17:00Z") (link ((href . "/articles/early-mixins-late-mixins") (rel . "alternate") (type . "text/html"))) (content ((type . "html")) "<p>In JavaScript, the language supplies us with several code reuse patterns. Prototype chaining gives us the primary single inheritance mechanism. Mixins are also an important pattern when we want one object to &ldquo;inherit&rdquo; functionality from multiple objects. There are several ways to implement the mixin process. This article looks at two contrasting implementations: early mixins and late mixins.</p>

<h2>Late Binding</h2>

<p>Let&rsquo;s start with a quick review of what late binding gives us.</p>

<pre><code>var adam = {
    greet: function() {
        return \"hello\";
    }
};

adam.greet(); // \"hello\"</code></pre>

<p>When we ask <code>adam</code> to <code>greet</code>, the method to be executed is looked up at the time of the call. This is late binding and means if we redefine the greet method, subsequent calls will use the new definition.</p>

<pre><code>adam.greet = function(name) {
    return \"hello\" + (name ? (\", \" + name) : \"\");
};

adam.greet(\"world\"); // \"hello, world\";</code></pre>

<p>This ability to redefine a method is valuable because it makes it possible for plugins to modify the behaviour of an existing code library.</p>


<h2>Late Binding and Prototype Chaining</h2>

<p>How does late binding work with prototype chaining? Let&rsquo;s start with a fresh example. First we&rsquo;ll make a new object <code>adam</code> who introduces himself.</p>

<pre><code>var adam = {
    _name: \"Adam\";
    greet: function() {
        return \"hello. I am \" + this._name;
    }
};</code></pre>

<p>Someone named Adam seems like a suitable prototype for all existing people. We can make a constructor function to produce more people.</p>

<pre><code>function Person(name) {
    this._name = name;
}
Person.prototype = adam;

var eve = new Person(\"Eve\");
eve.greet(); // \"hello. I am Eve\"</code></pre>

<p>Thanks to the combination of late binding and the prototype chain, a change to <code>adam</code> will result in a change to <code>eve</code> instantly. The following could be some plugin for the library that provides the <code>adam</code> object. This redefinition could happen at runtime due to user interaction.</p>

<pre><code>adam.greet = function(name) {
    return \"hello\" + (name ? (\", \" + name) : '') + \". I am \" + this._name;
};

eve.greet(\"world\"); // \"hello, world. I am Eve\"</code></pre>


<h2>Early Mixins</h2>

<p>Another way to create a reusable bunch of code as a library is to provide one object who&rsquo;s properties can be mixed into another object. This is usually done with an early mixin implementation.</p>

<p>First, a generic function that can mix properties from one object into another object.</p>

<pre><code>function earlyMixin(sink, source) {
    for (var property in source) {
        sink[property] = source[property];
    }
}</code></pre>

<p>Now a object containing methods that would be useful on another object. Here is a library called Speeches.JS.</p>

<pre><code>var speeches = {
    greet: function() {
        return \"hello. I am \" + this._name;
    },
    farewell: function() {
        return \"goodbye. I am \" + this._name;
    }
};</code></pre>

<p>Since this Speeches.JS library is already written and well unit tested, we&rsquo;d like to reuse that code in our code.</p>

<pre><code>function Person(name) {
    this._name = name;
}
earlyMixin(Person.prototype, speeches);

var adam = new Person('Adam');
adam.greet(); // \"hello. I am Adam\"</code></pre>

<p>Now suppose we have mixed this <code>speeches</code> object into several other objects (like the <code>Person.prototype</code> object.) Also suppose we want to modify the <code>speeches</code> object at some later time and have all objects who&rsquo;ve had the <code>speeches</code> object mixed into it be updated. This is what a plugin for Speeches.JS might want to do.</p> 

<pre><code>speeches.greet = function(name) {
    return \"hello\" + (name ? (\", \" + name) : '') + \". I am \" + this._name;
};</code></pre>

<p>Unfortunately we cannot do this because the <code>speeches</code> methods have been mixed into the <code>Person.prototype</code> object early (i.e. at the time of mixin.) We still have</p>

<pre><code>adam.greet(\"world\"); // \"hello. I am Adam\"</code></pre>

<h2>Late Mixins</h2>

<p>In order to make it possible to modify <code>speeches</code> and have all objects use the modified methods, we need one level of indirection in the mixin process.</p>

<pre><code>function lateMixin(sink, source) {
    for (var property in source) {
        (function(property) {
            sink[property] = function() {
                return source[property].apply(this, arguments);
            }
        }(property));
    }
}</code></pre>

<p>Instead of directly borrowing the methods of the <code>source</code>, the <code>sink</code> is given methods that call the methods of <code>source</code>. This means that the method on <code>source</code> are mixed in late because they are looked up when they are called (rather than when they are mixed in.)</p>

<p>Now we can go through the same example with a different result.</p>

<pre><code>var speeches = {
    greet: function() {
        return \"hello. I am \" + this._name;
    },
    farewell: function() {
        return \"goodbye. I am \" + this._name;
    }
};

function Person(name) {
    this._name = name;
}
lateMixin(Person.prototype, speeches);

var adam = new Person('Adam');
adam.greet(); // \"hello. I am Adam\"

speeches.greet = function(name) {
    return \"hello\" + (name ? (\", \" + name) : '') + \". I am \" + this._name;
};

adam.greet(\"world\"); // \"hello, world. I am Adam\"</code></pre>

<p>When <code>adam.greet</code> is called it uses the most recent definition of <code>speeches.greet</code>. Yay! Late mixins have given us the same dynamic power that late binding and the prototype chain give us. This makes a library like Speeches.JS more flexible and opens it up for various kinds of modification at run time.</p>

<h2>Not Quite Everything</h2>

<p>Late mixins give us some of the power of late binding and the prototype chain but not everything. If we add another method to the <code>speeches</code> object it is not added to the other objects into which <code>speeches</code> has been mixed. There are several ways to accomplish this type of functionality. Something like <a href=\"http://wiki.ecmascript.org/doku.php?id=harmony%3adirect_proxies\" target=\"_blank\">proxies</a> might be our answer to get closer to real multiple inheritance.</p>
"))) ("uMVC - A micro MVC framework in JavaScript" "<p><a href=\"https://twitter.com/petermichaux/status/221671174915104768\" title=\"@petermichaux on Twitter\" target=\"_blank\">I tweeted:</a></p>
<blockquote>
<p>You can write an MVC framework in one hundred lines of JavaScript &amp; write about its effective use for one hundred thousand lines of English.</p>
</blockquote>
<p>I wondered exactly how small I could write a respectable MVC framework that included the three fundamental design patterns of the traditional Smalltalk-style MVC: the observer, composite, and strategy patterns.</p>
<p>See <a href=\"https://github.com/petermichaux/uMVC/blob/master/uMVC.js\" target=\"_blank\">the uMVC code on Github</a>.</p>
<p>Hopefully this code is educational for those new to the MVC paradigm. I think this code is something every JavaScript programmer should understand inside out and be able to explain every individual line&rsquo;s significance to another programmer new to MVC.</p>
<p>If you are looking for a more fully-featured MVC framework that follows the same principles of uMVC to use in real browser applications, I suggest you take a look at <a href=\"https://github.com/petermichaux/maria\" target=\"_blank\">Maria</a>.</p>" "/articles/uMVC" (20601 51264) old 2 nil nil ((id nil "http://peter.michaux.ca/articles/uMVC") (title nil "uMVC - A micro MVC framework in JavaScript") (updated nil "2012-10-13T20:00:00Z") (link ((href . "/articles/uMVC") (rel . "alternate") (type . "text/html"))) (content ((type . "html")) "<p><a href=\"https://twitter.com/petermichaux/status/221671174915104768\" title=\"@petermichaux on Twitter\" target=\"_blank\">I tweeted:</a></p>

<blockquote>
<p>You can write an MVC framework in one hundred lines of JavaScript &amp; write about its effective use for one hundred thousand lines of English.</p>
</blockquote>

<p>I wondered exactly how small I could write a respectable MVC framework that included the three fundamental design patterns of the traditional Smalltalk-style MVC: the observer, composite, and strategy patterns.</p>

<p>See <a href=\"https://github.com/petermichaux/uMVC/blob/master/uMVC.js\" target=\"_blank\">the uMVC code on Github</a>.</p>

<p>Hopefully this code is educational for those new to the MVC paradigm. I think this code is something every JavaScript programmer should understand inside out and be able to explain every individual line&rsquo;s significance to another programmer new to MVC.</p>

<p>If you are looking for a more fully-featured MVC framework that follows the same principles of uMVC to use in real browser applications, I suggest you take a look at <a href=\"https://github.com/petermichaux/maria\" target=\"_blank\">Maria</a>.</p>
"))) ("Less English, more JavaScript" "<p>I haven&rsquo;t written much for my website this year. It wasn&rsquo;t an accident. I wasn&rsquo;t too busy. It was a choice. My new year&rsquo;s resolution for 2012 was to write less English and more JavaScript.</p>
<p>Three quarters of the year is now gone and I feel like I&rsquo;ve satisfied that resolution with 11 new JavaScript repositories <a href=\"https://github.com/petermichaux\" target=\"_blank\">on Github</a>. Most of the work was driven by the development of the <a href=\"https://github.com/petermichaux/maria\" target=\"_blank\">Maria framework</a> for writing MVC-style browser application. That particular project has been great fun and satisfying.</p>
<p>Now I feel as through I should tell the world about these projects &hellip; but part of me just wants to continue writing more JavaScript.</p>" "/articles/less-English-more-JavaScript" (20601 47664) old 3 nil nil ((id nil "http://peter.michaux.ca/articles/less-English-more-JavaScript") (title nil "Less English, more JavaScript") (updated nil "2012-10-13T19:00:00Z") (link ((href . "/articles/less-English-more-JavaScript") (rel . "alternate") (type . "text/html"))) (content ((type . "html")) "<p>I haven&rsquo;t written much for my website this year. It wasn&rsquo;t an accident. I wasn&rsquo;t too busy. It was a choice. My new year&rsquo;s resolution for 2012 was to write less English and more JavaScript.</p>

<p>Three quarters of the year is now gone and I feel like I&rsquo;ve satisfied that resolution with 11 new JavaScript repositories <a href=\"https://github.com/petermichaux\" target=\"_blank\">on Github</a>. Most of the work was driven by the development of the <a href=\"https://github.com/petermichaux/maria\" target=\"_blank\">Maria framework</a> for writing MVC-style browser application. That particular project has been great fun and satisfying.</p>

<p>Now I feel as through I should tell the world about these projects &hellip; but part of me just wants to continue writing more JavaScript.</p>

"))) ("Organizing Browser Application Files" "<p>If you are building a large, one-page browser application with the usual suspects of HTML, CSS, JavaScript, images, etc, you&rsquo;ll have many files and staying organized is important. Here is a way to organize your files.</p>
<h2>General Structure</h2>
<pre><code>MyApp/
Makefile
README
etc/
lib/
src/
tst/</code></pre>
<p>Perhaps the first thing you will do when starting the project is fill the <code>lib</code> directory with all the third-party libraries you know you&rsquo;ll be using. These libraries are dropped into the <code>lib</code> directory without modification. Just plop them there in the same form they are distributed. You aren&rsquo;t allowed to edit these files. This directory is the only directory where you put files created by a third party.</p>
<p>The <code>src</code> directory contains all of the files that you create and write that will become part of the files downloaded by the browser of a user of your application. These are the files we are excited about writing.</p>
<p>The <code>tst</code> directory contains all the files that test the files in the <code>src</code> directory. These are the files we are not excited about writing.</p>
<p>The <code>Makefile</code> has a default <code>build</code> target that generates the directory called <code>bld</code> which is filled with production-ready files that can be copied to the production web servers. The files in the <code>lib</code> and <code>src</code> directories are combined, minified, compressed, and otherwise mutated to become the files in the <code>bld</code> directory. This target can possibly generate a <code>MyApp.tar.gz</code> file if that is how the distribution to production will be done.</p>
<p>The build process may be guided by data in files in the <code>etc</code> directory. For example, there may be manifest files that state which files are concatenated together during the build and the name of the resulting files. Exactly which files with which data are in your <code>etc</code> directory depend on which tools you are using in your build process.</p>
<p>The <code>Makefile</code> should have a <code>clean</code> target that deletes the <code>bld</code> directory.</p>
<p>The <code>Makefile</code> might have a <code>test</code> target that runs the tests in the <code>tst</code> directory.</p>
<p>The <code>README</code> should at least explain what the targets in the Makefile do and how to run the tests.</p>
<p>You should not need to run <code>make build</code> in order to test your application either with the files in the <code>tst</code> directory or in the browser while developing. You may have files in your <code>etc</code> directory that control how the development environment is configured.</p>
<h2>An MVC-style Application</h2>
<p>You might be using an MVC framework like <a href=\"https://github.com/petermichaux/maria\" target=\"_blank\">Maria</a> to help structure your JavaScript. In this case, there is a natural way to divide your application at a finer scale.</p>
<pre><code>MyApp/
Makefile
README
etc/
lib/
maria.js
src/
css/
html/
index.html
templates/
img/
js/
bootstrap.js
controllers/
models/
views/
util/
tst/</code></pre>
<p>The <code>index.html</code> files is the page that the user loads into their browser to start the one-page application. This may be named something different like <code>myapp.html</code>. This file loads the necessary CSS, image, template, and JavaScript files needed to run the application.</p>
<p>The <code>templates</code> directory contains any HTML templates used by your JavaScript views. These can be compiled to JavaScript and concatenated into one or a few JavaScript files during the build process.</p>
<p>The <code>bootstrap.js</code> file is the one with the call to <code>window.onload</code> that fires up the whole application. It will start the loading of the data from the server, create the model layer, build the views, and add those views to the page so the user can begin interacting with the application.</p>
<p>The <code>controllers</code>, <code>models</code>, and <code>views</code> directories contain the obvious.</p>
<p>The <code>util</code> directory contains utility code that is not specific to any of the model, view, or controller layers. There may be pure functions that make computations with no side effects. You might have some obscure DOM related utilities that you wish were written by a third party for your <code>lib</code> directory but that you have to write yourself for your unique browser scripting requirements.</p>" "/articles/organizing-browser-application-files" (20600 41200) old 4 nil nil ((id nil "http://peter.michaux.ca/articles/organizing-browser-application-files") (title nil "Organizing Browser Application Files") (updated nil "2012-10-12T23:00:00Z") (link ((href . "/articles/organizing-browser-application-files") (rel . "alternate") (type . "text/html"))) (content ((type . "html")) "<p>If you are building a large, one-page browser application with the usual suspects of HTML, CSS, JavaScript, images, etc, you&rsquo;ll have many files and staying organized is important. Here is a way to organize your files.</p>


<h2>General Structure</h2>

<pre><code>MyApp/
    Makefile
    README
    etc/
    lib/
    src/
    tst/</code></pre>

<p>Perhaps the first thing you will do when starting the project is fill the <code>lib</code> directory with all the third-party libraries you know you&rsquo;ll be using. These libraries are dropped into the <code>lib</code> directory without modification. Just plop them there in the same form they are distributed. You aren&rsquo;t allowed to edit these files. This directory is the only directory where you put files created by a third party.</p>

<p>The <code>src</code> directory contains all of the files that you create and write that will become part of the files downloaded by the browser of a user of your application. These are the files we are excited about writing.</p>

<p>The <code>tst</code> directory contains all the files that test the files in the <code>src</code> directory. These are the files we are not excited about writing.</p>

<p>The <code>Makefile</code> has a default <code>build</code> target that generates the directory called <code>bld</code> which is filled with production-ready files that can be copied to the production web servers. The files in the <code>lib</code> and <code>src</code> directories are combined, minified, compressed, and otherwise mutated to become the files in the <code>bld</code> directory. This target can possibly generate a <code>MyApp.tar.gz</code> file if that is how the distribution to production will be done.</p>

<p>The build process may be guided by data in files in the <code>etc</code> directory. For example, there may be manifest files that state which files are concatenated together during the build and the name of the resulting files. Exactly which files with which data are in your <code>etc</code> directory depend on which tools you are using in your build process.</p>

<p>The <code>Makefile</code> should have a <code>clean</code> target that deletes the <code>bld</code> directory.</p>

<p>The <code>Makefile</code> might have a <code>test</code> target that runs the tests in the <code>tst</code> directory.</p>

<p>The <code>README</code> should at least explain what the targets in the Makefile do and how to run the tests.</p>

<p>You should not need to run <code>make build</code> in order to test your application either with the files in the <code>tst</code> directory or in the browser while developing. You may have files in your <code>etc</code> directory that control how the development environment is configured.</p>


<h2>An MVC-style Application</h2>

<p>You might be using an MVC framework like <a href=\"https://github.com/petermichaux/maria\" target=\"_blank\">Maria</a> to help structure your JavaScript. In this case, there is a natural way to divide your application at a finer scale.</p>

<pre><code>MyApp/
    Makefile
    README
    etc/
    lib/
        maria.js
    src/
        css/
        html/
            index.html
            templates/
        img/
        js/
            bootstrap.js
            controllers/
            models/
            views/
            util/
    tst/</code></pre>

<p>The <code>index.html</code> files is the page that the user loads into their browser to start the one-page application. This may be named something different like <code>myapp.html</code>. This file loads the necessary CSS, image, template, and JavaScript files needed to run the application.</p>

<p>The <code>templates</code> directory contains any HTML templates used by your JavaScript views. These can be compiled to JavaScript and concatenated into one or a few JavaScript files during the build process.</p>

<p>The <code>bootstrap.js</code> file is the one with the call to <code>window.onload</code> that fires up the whole application. It will start the loading of the data from the server, create the model layer, build the views, and add those views to the page so the user can begin interacting with the application.</p>

<p>The <code>controllers</code>, <code>models</code>, and <code>views</code> directories contain the obvious.</p>

<p>The <code>util</code> directory contains utility code that is not specific to any of the model, view, or controller layers. There may be pure functions that make computations with no side effects. You might have some obscure DOM related utilities that you wish were written by a third party for your <code>lib</code> directory but that you have to write yourself for your unique browser scripting requirements.</p>

"))) ("Mixins and Constructor Functions" "<p>JavaScript allows programmers to take properties from one object and mix them into another object. There are several ways to accomplish this mixing and a few of them are explored here.</p>
<h2>Observable Mixin</h2>
<p>Here is a simple example of the observer pattern that can be mixed into other objects.</p>
<pre><code>var observableMethods = {
observe: function(observer) {
if (!this.hasOwnProperty('observers')) {
this.observers = [];
}
this.observers.push(observer);
},
notify: function(data) {
if (this.hasOwnProperty('observers')) {
for (var i=0, ilen=this.observers.length; i&lt;ilen; i++) {
this.observers[i](data);
}
}
}
};</code></pre>
<p>It is possible to use the <code>observableMethods</code> function as a observable itself.</p>
<pre><code>observableMethods.observe(function() {
alert('hi');
});
observableMethods.notify();</code></pre>
<p>A little mixin function to make other things observable.</p>
<pre><code>function mixinObservable(sink) {
for (var p in observableMethods) {
if (observableMethods.hasOwnProperty(p) &amp;&amp;
typeof observableMethods[p] === 'function') {
sink[p] = observableMethods[p];
}
}
}</code></pre>
<p>We can mixin to an person created with an object literal.</p>
<pre><code>var person = {
name: 'Steve',
setName: function(name) {
var oldName = this.name;
this.name = name;
this.notify({oldName: oldName, newName: this.name});
}
};
mixinObservable(person);
person.observe(function(data) {
alert(data.oldName + ' was renamed to ' + data.newName);
});
person.setName('Sarah');</code></pre>
<p>Alternately we write a constructor function for observable people that we can rename.</p>
<pre><code>function Person(name) {
this.setName(name);
};
mixinObservable(Person.prototype);
Person.prototype.setName = function(name) {
var oldName = this.name;
this.name = name;
this.notify({oldName:oldName, newName:this.name});
};</code></pre>
<p>We can then make a person and manipulate it.</p>
<pre><code>var person = new Person('Steve');
person.observe(function(data) {
alert(data.oldName + ' was renamed to ' + data.newName);
});
person.setName('Sarah');</code></pre>
<p>In all of the above code, the three uses of <code>hasOwnProperty</code> are critical to understand.</p>
<p>The first two uses of <code>hasOwnProperty</code> in <code>observe</code> and <code>notify</code> ensure that the object into which the methods have been mixed, will have its own set observers and not share some set of observers with any other object. The unfortunate part is that these checks run every time the <code>observe</code> and <code>notify</code> methods are called. This is inefficient and something we want to fix.</p>
<p>The third use of <code>hasOwnProperty</code> in <code>mixinObservable</code> means that only properties directly on <code>observableMethods</code> will be mixed into other objects. This is important because if we do not use <code>hasOwnProperty</code> then we copy all of the enumerable <code>Object.prototype</code> properties which is either wasteful or will overwrite any custom methods with the same names on other objects.</p>
<p>The <code>mixinObservable</code> function also copies only functions. If this check was not made and someone had observed the <code>observableMethods</code> object itself then the <code>observableMethods.observes</code> array would be copied as part of every mixin and observers would be shared by some observable objects (e.g. <code>observableMethods</code> and <code>Person.prototype</code> in the example above.)</p>
<p>A simpler <code>mixinObservable</code> method could be the following but this could be more difficult to maintain. If more methods are added to <code>observableMethods</code> then they need to be explicitly listed in <code>mixinObservable</code>.</p>
<pre><code>function mixinObservable(sink) {
sink.observe = observableMethods.observe;
sink.notify = observableMethods.notify;
}</code></pre>
<h2>Fixing the Inefficiency</h2>
<p>The inefficiency in <code>observe</code> and <code>notify</code> can be fixed by making a constructor function for <code>Observable</code> objects.</p>
<pre><code>function Observable() {
this.observers = [];
}
Observable.prototype.observe = function(observer) {
this.observers.push(observer);
};
Observable.prototype.notify = function(data) {
for (var i=0, ilen=this.observers.length; i&lt;ilen; i++) {
this.observers[i](data);
}
};
Observable.call(Observable.prototype); // optional depending what you want</code></pre>
<p>Now the <code>observe</code> and <code>notify</code> methods of an observable function are more efficient as we know the <code>observers</code> property was created when the <code>Observable</code> constructor function ran.</p>
<p>The last line, <code>Observable.call(Observable.prototype);</code>, is a bit of an unusual one but it makes it possible to observe <code>Observable.prototype</code> just like <code>observableMethods</code>.</p>
<p>A new mixin function.</p>
<pre><code>function mixinObservable(sink) {
for (var p in Observable.prototype) {
if (Observable.prototype.hasOwnProperty(p) &amp;&amp;
typeof Observable.prototype[p] === 'function') {
sink[p] = Observable.prototype[p];
}
}
Observable.call(sink); // optional depending what you want
}</code></pre>
<p>Mixing into a person created with an object literal just like it was done above. The last line of this new <code>mixinObservable</code> insures the <code>observers</code> property is created.</p>
<pre><code>var person = {
name: 'Steve',
setName: function(name) {
var oldName = this.name;
this.name = name;
this.notify({oldName: oldName, newName: this.name});
}
};
mixinObservable(person);
person.observe(function(data) {
alert(data.oldName + ' was renamed to ' + data.newName);
});
person.setName('Sarah');</code></pre>
<p>The trick comes when we create a <code>Person</code> constructor function.</p>
<pre><code>function Person(name) {
Observable.call(this);
this.setName(name);
};
mixinObservable(Person.prototype);
Person.prototype.setName = function(name) {
var oldName = this.name;
this.name = name;
this.notify({oldName:oldName, newName:this.name});
};</code></pre>
<p>The first line of the constructor function, <code>Observable.call(this);</code>, ensures that each <code>Person</code> object has its own set of observers. Without this call, all the people will share the same list of observers which is the set of observers on the <code>Person.prototype</code> object. If this makes you squint then it is well worth the effort to think about it until it is clear why.</p>
<p>To use some class vocabulary, the first line of the constructor function can be thought of as a <code>super</code> call and that the Person class inherits from the Observable class. Some JavaScript diehards cringe at the mention of this vocabulary but I think the comparison is worth consideration.</p>
<h2>Multiple Mixins</h2>
<p>Multiple mixins follow the same pattern.</p>
<pre><code>function Person(name) {
Observable.call(this);
Common.call(this);
this.setName(name);
}
mixinObservable(Person.prototype);
mixinCommon(Person.prototype);
// By coincidence mixinCommon also added a notify method which
// clobbered the method of the same name added by mixinObservable.
// Fix this problem making appropriate decisions about how
// to call both.
Person.prototype.notify = function() {
Common.prototype.notify.call(this);
Observable.prototype.notify.apply(this, arguments);
};
// ...</code></pre>
<h2>Prototype Chaining vs. Mixins</h2>
<p>There is one primary difference between prototype chaining and mixins. For example,</p>
<pre><code>function Person(name) {
Observable.call(this);
Base.call(this);
this.setName(name);
}
// chain prototypes so that all Person objects
// inherit from Base.prototype.
Person.prototype = Object.create(Base.prototype);
Person.prototype.constructor = Person;
Base.call(Person.prototype); // optional depending what you want
mixinObservable(Person.prototype);</code></pre>
<p>Now if we add methods to both <code>Base.prototype</code> and <code>Observable.prototype</code> <em>after</em> the above code has executed. Only the method added to <code>Base.prototype</code> will be added to <code>Person</code> objects.</p>
<pre><code>Base.prototype.getId = function() {/*...*/};
Observable.prototype.getObservers = function() {/*...*/};
var person = new Person('Steve');
person.getId(); // ok
person.getObservers(); // error: getObservers not defined</code></pre>
<p>Enjoy your mixins.</p>" "/articles/mixins-and-constructor-functions" (20373 47232) old 5 nil nil ((id nil "http://peter.michaux.ca/articles/mixins-and-constructor-functions") (title nil "Mixins and Constructor Functions") (updated nil "2012-04-23T20:16:00Z") (link ((href . "/articles/mixins-and-constructor-functions") (rel . "alternate") (type . "text/html"))) (content ((type . "html")) "<p>JavaScript allows programmers to take properties from one object and mix them into another object. There are several ways to accomplish this mixing and a few of them are explored here.</p>


<h2>Observable Mixin</h2>

<p>Here is a simple example of the observer pattern that can be mixed into other objects.</p>

<pre><code>var observableMethods = {
    observe: function(observer) {
        if (!this.hasOwnProperty('observers')) {
            this.observers = [];
        }
        this.observers.push(observer);
    },
    notify: function(data) {
        if (this.hasOwnProperty('observers')) {
            for (var i=0, ilen=this.observers.length; i&lt;ilen; i++) {
                this.observers[i](data);
            }
        }
    }
};</code></pre>

<p>It is possible to use the <code>observableMethods</code> function as a observable itself.</p>

<pre><code>observableMethods.observe(function() {
    alert('hi');
});
observableMethods.notify();</code></pre>

<p>A little mixin function to make other things observable.</p>

<pre><code>function mixinObservable(sink) {
    for (var p in observableMethods) {
        if (observableMethods.hasOwnProperty(p) &amp;&amp;
            typeof observableMethods[p] === 'function') {
            sink[p] = observableMethods[p];
        }
    }
}</code></pre>

<p>We can mixin to an person created with an object literal.</p>

<pre><code>var person = {
    name: 'Steve',
    setName: function(name) {
        var oldName = this.name;
        this.name = name;
        this.notify({oldName: oldName, newName: this.name});
    }
};
mixinObservable(person);
person.observe(function(data) {
    alert(data.oldName + ' was renamed to ' + data.newName);
});
person.setName('Sarah');</code></pre>

<p>Alternately we write a constructor function for observable people that we can rename.</p>

<pre><code>function Person(name) {
    this.setName(name);
};

mixinObservable(Person.prototype);

Person.prototype.setName = function(name) {
    var oldName = this.name;
    this.name = name;
    this.notify({oldName:oldName, newName:this.name});
};</code></pre>

<p>We can then make a person and manipulate it.</p>

<pre><code>var person = new Person('Steve');
person.observe(function(data) {
    alert(data.oldName + ' was renamed to ' + data.newName);
});
person.setName('Sarah');</code></pre>

<p>In all of the above code, the three uses of <code>hasOwnProperty</code> are critical to understand.</p>

<p>The first two uses of <code>hasOwnProperty</code> in <code>observe</code> and <code>notify</code> ensure that the object into which the methods have been mixed, will have its own set observers and not share some set of observers with any other object. The unfortunate part is that these checks run every time the <code>observe</code> and <code>notify</code> methods are called. This is inefficient and something we want to fix.</p>

<p>The third use of <code>hasOwnProperty</code> in <code>mixinObservable</code> means that only properties directly on <code>observableMethods</code> will be mixed into other objects. This is important because if we do not use <code>hasOwnProperty</code> then we copy all of the enumerable <code>Object.prototype</code> properties which is either wasteful or will overwrite any custom methods with the same names on other objects.</p>

<p>The <code>mixinObservable</code> function also copies only functions. If this check was not made and someone had observed the <code>observableMethods</code> object itself then the <code>observableMethods.observes</code> array would be copied as part of every mixin and observers would be shared by some observable objects (e.g. <code>observableMethods</code> and <code>Person.prototype</code> in the example above.)</p>

<p>A simpler <code>mixinObservable</code> method could be the following but this could be more difficult to maintain. If more methods are added to <code>observableMethods</code> then they need to be explicitly listed in <code>mixinObservable</code>.</p>

<pre><code>function mixinObservable(sink) {
    sink.observe = observableMethods.observe;
    sink.notify = observableMethods.notify;
}</code></pre>

<h2>Fixing the Inefficiency</h2>

<p>The inefficiency in <code>observe</code> and <code>notify</code> can be fixed by making a constructor function for <code>Observable</code> objects.</p>

<pre><code>function Observable() {
    this.observers = [];
}
Observable.prototype.observe = function(observer) {
    this.observers.push(observer);
};
Observable.prototype.notify = function(data) {
    for (var i=0, ilen=this.observers.length; i&lt;ilen; i++) {
        this.observers[i](data);
    }
};
Observable.call(Observable.prototype); // optional depending what you want</code></pre>

<p>Now the <code>observe</code> and <code>notify</code> methods of an observable function are more efficient as we know the <code>observers</code> property was created when the <code>Observable</code> constructor function ran.</p>

<p>The last line, <code>Observable.call(Observable.prototype);</code>, is a bit of an unusual one but it makes it possible to observe <code>Observable.prototype</code> just like <code>observableMethods</code>.</p>

<p>A new mixin function.</p>

<pre><code>function mixinObservable(sink) {
    for (var p in Observable.prototype) {
        if (Observable.prototype.hasOwnProperty(p) &amp;&amp;
            typeof Observable.prototype[p] === 'function') {
            sink[p] = Observable.prototype[p];
        }
    }
    Observable.call(sink); // optional depending what you want
}</code></pre>

<p>Mixing into a person created with an object literal just like it was done above. The last line of this new <code>mixinObservable</code> insures the <code>observers</code> property is created.</p>

<pre><code>var person = {
    name: 'Steve',
    setName: function(name) {
        var oldName = this.name;
        this.name = name;
        this.notify({oldName: oldName, newName: this.name});
    }
};
mixinObservable(person);
person.observe(function(data) {
    alert(data.oldName + ' was renamed to ' + data.newName);
});
person.setName('Sarah');</code></pre>

<p>The trick comes when we create a <code>Person</code> constructor function.</p>

<pre><code>function Person(name) {
    Observable.call(this);
    this.setName(name);
};

mixinObservable(Person.prototype);

Person.prototype.setName = function(name) {
    var oldName = this.name;
    this.name = name;
    this.notify({oldName:oldName, newName:this.name});
};</code></pre>

<p>The first line of the constructor function, <code>Observable.call(this);</code>, ensures that each <code>Person</code> object has its own set of observers. Without this call, all the people will share the same list of observers which is the set of observers on the <code>Person.prototype</code> object. If this makes you squint then it is well worth the effort to think about it until it is clear why.</p>

<p>To use some class vocabulary, the first line of the constructor function can be thought of as a <code>super</code> call and that the Person class inherits from the Observable class. Some JavaScript diehards cringe at the mention of this vocabulary but I think the comparison is worth consideration.</p>


<h2>Multiple Mixins</h2>

<p>Multiple mixins follow the same pattern.</p>

<pre><code>function Person(name) {
    Observable.call(this);
    Common.call(this);
    this.setName(name);
}

mixinObservable(Person.prototype);
mixinCommon(Person.prototype);

// By coincidence mixinCommon also added a notify method which
// clobbered the method of the same name added by mixinObservable.
// Fix this problem making appropriate decisions about how
// to call both.
Person.prototype.notify = function() {
    Common.prototype.notify.call(this);
    Observable.prototype.notify.apply(this, arguments);
};
// ...</code></pre>


<h2>Prototype Chaining vs. Mixins</h2>

<p>There is one primary difference between prototype chaining and mixins. For example,</p>

<pre><code>function Person(name) {
    Observable.call(this);
    Base.call(this);
    this.setName(name);
}

// chain prototypes so that all Person objects
// inherit from Base.prototype.
Person.prototype = Object.create(Base.prototype);
Person.prototype.constructor = Person;
Base.call(Person.prototype); // optional depending what you want

mixinObservable(Person.prototype);</code></pre>

<p>Now if we add methods to both <code>Base.prototype</code> and <code>Observable.prototype</code> <em>after</em> the above code has executed. Only the method added to <code>Base.prototype</code> will be added to <code>Person</code> objects.</p>

<pre><code>Base.prototype.getId = function() {/*...*/};
Observable.prototype.getObservers = function() {/*...*/};

var person = new Person('Steve');
person.getId(); // ok
person.getObservers(); // error: getObservers not defined</code></pre>

<p>Enjoy your mixins.</p>

"))) ("Our Backwards DOM Event Libraries" "<h2>The Browser APIs</h2>
<p>A brief review of what the browsers give us to attach event listeners to DOM elements so we can do fancy stuff when the user interacts with the page.</p>
<p>Internet Explorer gives us <code>element.attachEvent</code> allowing us to attach a listener <em>function</em> to an element.</p>
<pre><code>document.body.attachEvent(
'onclick',
function() {
alert('body clicked');
});
</code></pre>
<p>The other browsers give us <code>element.addEventListener</code>. The use with which we are most familiar is supplying a listener <em>function</em> as the second argument.<p>
<pre><code>document.body.addEventListener(
'click',
function() {
alert('body clicked');
},
false);
</code></pre>
<p>Many JavaScript programmers don&rsquo;t know that it is also possible to send a listener <em>object</em> as the second argument to <code>addEventListener</code>. When an event is fired, the object&rsquo;s <code>handleEvent</code> method is called.</p>
<pre><code>document.body.addEventListener(
'click',
{
handleEvent: function() {
alert('body clicked');
}
},
false);
</code></pre>
<p>An important feature of using a listener <em>object</em> is that the function value of it&rsquo;s <code>handleEvent</code> property is only looked up when the event is fired. This means that if the function value of the <code>handleEvent</code> property changes between events then it is always the current value of the <code>handleEvent</code> property that is called. This is late binding. For example,</p>
<pre><code>var obj = {};
document.body.addEventListener('click', obj, false);
// click body will error in some browsers because
// no handleEvent method on obj
obj.handleEvent = function() {alert('alpha');};
// click body and see alert \"alpha\"
obj.handleEvent = function() {alert('beta');};
// click body and see alert \"beta\"
document.body.removeEventListener('click', obj, false);
// click body and see nothing
</code></pre>
<h2>Cross-Browser Libraries</h2>
<p>Our cross-browser applications should not be cluttered with repetitive code to work with the different APIs provided by the different browsers, so we&rsquo;ve abstracted the different APIs away in event libraries. This has been a very good choice.</p>
<p>Different libraries have different APIs but every library has something like the following.</p>
<pre><code>LIB_addEventListener(
document.body,
'click',
function() {
alert('body clicked');
});
</code></pre>
<h2>The JavaScript <code>this</code> Wrinkle</h2>
<p>A common problem with these library abstractions is when we want a method of an view object to be called when the event is fired. For example, in the following code, the value of <code>this</code> in the <code>handleClick</code> method is the global <code>window</code> object. The alert will show <code>undefined</code> when we may have expected to see the alert show <code>\"alpha\"</code>.</p>
<pre><code>function ViewObject() {
this.data = 'alpha';
LIB_addEventListener(
document.body,
'click',
this.handleClick);
}
ViewObject.prototype.handleClick = function() {
alert(this.data);
};
</code></pre>
<p>The workaround the libraries have given us (so that we can also still easily remove event listeners) is to specify the object we want as <code>this</code> when the handler is called as an extra argument to the event library function. For example, the alert in this example will show <code>\"alpha\"</code>.</p>
<pre><code>function ViewObject() {
this.data = 'alpha';
LIB_addEventListener(
document.body,
'click',
this.handleClick,
this);
}
ViewObject.prototype.handleClick = function() {
alert(this.data);
};
ViewObject.prototype.destroy = function() {
LIB_removeEventListener(
document.body,
'click',
this.handleClick,
this
);
};
</code></pre>
<p>One problem with this API is that the listener <em>function</em> is bound when <code>LIB_addEventListener</code> is called. This causes trouble when the function value of <code>handleClick</code> is changed and then also when an attempt is made to remove the listener.</p>
<pre><code>var vo = new ViewObject();
// click on the body and see alert \"alpha\"
vo.handleClick = function() {
alert('beta');
};
// click on the body and still see \"alpha\"
vo.destroy();
// click on the body and still see \"alpha\"!
</code></pre>
<p>Another problem is that we are writing the program in an object-oriented style but we are focusing on listener <em>functions</em> rather than listener <em>objects</em>. This mismatch is a clue to find a better solution.</p>
<h2>A Library API for Listener Objects</h2>
<p>Since we are frequently writing our programs in an object-oriented style, it makes sense to write <code>LIB_addEventListener</code> so that it can accept listener <em>objects</em> (as well as listener <em>functions</em>.)</p>
<pre><code>var obj = {
handleEvent: function() {
alert('click handler');
}
};
LIB_addEventListener(document.body, 'click', obj);
</code></pre>
<p>Frequently we have one view object handling multiple types of events for various elements. A fourth parameter specifying the method name would allow that easily and still keep late binding.</p>
<pre><code>var obj = {
handleMouseDown: function() {
alert('mouse down handler');
},
handleMouseUp: function() {
alert('mouse up handler');
}
};
LIB_addEventListener(document.body, 'mousedown', obj, 'handleMouseDown');
LIB_addEventListener(document.body, 'mouseup', obj, 'handleMouseUp');
</code></pre>
<p>This API still allows for listener <em>functions</em> by looking at the type of the third argument.</p>
<pre><code>LIB_addEventListener(document.body, 'mousedown', function() {
alert('mousedown');
});
</code></pre>
<p>But now there is no need for specifying the <code>this</code> object that will be used when the listener <em>function</em> is called because we have something better suited to the task: listener <em>objects</em>.</p>" "/articles/our-backwards-dom-event-libraries" (20306 33544) old 6 nil nil ((id nil "http://peter.michaux.ca/articles/our-backwards-dom-event-libraries") (title nil "Our Backwards DOM Event Libraries") (updated nil "2012-03-03T20:46:00Z") (link ((href . "/articles/our-backwards-dom-event-libraries") (rel . "alternate") (type . "text/html"))) (content ((type . "html")) "<h2>The Browser APIs</h2>

<p>A brief review of what the browsers give us to attach event listeners to DOM elements so we can do fancy stuff when the user interacts with the page.</p>

<p>Internet Explorer gives us <code>element.attachEvent</code> allowing us to attach a listener <em>function</em> to an element.</p>

<pre><code>document.body.attachEvent(
    'onclick',
    function() {
        alert('body clicked');
    });
</code></pre>

<p>The other browsers give us <code>element.addEventListener</code>. The use with which we are most familiar is supplying a listener <em>function</em> as the second argument.<p>

<pre><code>document.body.addEventListener(
    'click',
    function() {
        alert('body clicked');
    },
    false);
</code></pre>

<p>Many JavaScript programmers don&rsquo;t know that it is also possible to send a listener <em>object</em> as the second argument to <code>addEventListener</code>. When an event is fired, the object&rsquo;s <code>handleEvent</code> method is called.</p>

<pre><code>document.body.addEventListener(
    'click',
    {
        handleEvent: function() {
            alert('body clicked');
        }
    },
    false);
</code></pre>

<p>An important feature of using a listener <em>object</em> is that the function value of it&rsquo;s <code>handleEvent</code> property is only looked up when the event is fired. This means that if the function value of the <code>handleEvent</code> property changes between events then it is always the current value of the <code>handleEvent</code> property that is called. This is late binding. For example,</p>

<pre><code>var obj = {};

document.body.addEventListener('click', obj, false);

// click body will error in some browsers because
// no handleEvent method on obj

obj.handleEvent = function() {alert('alpha');};

// click body and see alert \"alpha\"

obj.handleEvent = function() {alert('beta');};

// click body and see alert \"beta\"

document.body.removeEventListener('click', obj, false);

// click body and see nothing
</code></pre>

<h2>Cross-Browser Libraries</h2>

<p>Our cross-browser applications should not be cluttered with repetitive code to work with the different APIs provided by the different browsers, so we&rsquo;ve abstracted the different APIs away in event libraries. This has been a very good choice.</p>

<p>Different libraries have different APIs but every library has something like the following.</p>

<pre><code>LIB_addEventListener(
    document.body, 
    'click', 
    function() {
        alert('body clicked');
    });
</code></pre>

<h2>The JavaScript <code>this</code> Wrinkle</h2>
    
<p>A common problem with these library abstractions is when we want a method of an view object to be called when the event is fired. For example, in the following code, the value of <code>this</code> in the <code>handleClick</code> method is the global <code>window</code> object. The alert will show <code>undefined</code> when we may have expected to see the alert show <code>\"alpha\"</code>.</p>

<pre><code>function ViewObject() {
    this.data = 'alpha';
    LIB_addEventListener(
        document.body, 
        'click', 
        this.handleClick);
}
ViewObject.prototype.handleClick = function() {
    alert(this.data);
};
</code></pre>

<p>The workaround the libraries have given us (so that we can also still easily remove event listeners) is to specify the object we want as <code>this</code> when the handler is called as an extra argument to the event library function. For example, the alert in this example will show <code>\"alpha\"</code>.</p>

<pre><code>function ViewObject() {
    this.data = 'alpha';
    LIB_addEventListener(
        document.body, 
        'click', 
        this.handleClick,
        this);
}
ViewObject.prototype.handleClick = function() {
    alert(this.data);
};
ViewObject.prototype.destroy = function() {
    LIB_removeEventListener(
        document.body,
        'click',
        this.handleClick,
        this
    );
};
</code></pre>

<p>One problem with this API is that the listener <em>function</em> is bound when <code>LIB_addEventListener</code> is called. This causes trouble when the function value of <code>handleClick</code> is changed and then also when an attempt is made to remove the listener.</p>

<pre><code>var vo = new ViewObject();

// click on the body and see alert \"alpha\"

vo.handleClick = function() {
    alert('beta');
};

// click on the body and still see \"alpha\"

vo.destroy();

// click on the body and still see \"alpha\"!
</code></pre>

<p>Another problem is that we are writing the program in an object-oriented style but we are focusing on listener <em>functions</em> rather than listener <em>objects</em>. This mismatch is a clue to find a better solution.</p>

<h2>A Library API for Listener Objects</h2>

<p>Since we are frequently writing our programs in an object-oriented style, it makes sense to write <code>LIB_addEventListener</code> so that it can accept listener <em>objects</em> (as well as listener <em>functions</em>.)</p>

<pre><code>var obj = {
    handleEvent: function() {
        alert('click handler');
    }
};
LIB_addEventListener(document.body, 'click', obj);
</code></pre>

<p>Frequently we have one view object handling multiple types of events for various elements. A fourth parameter specifying the method name would allow that easily and still keep late binding.</p>

<pre><code>var obj = {
    handleMouseDown: function() {
        alert('mouse down handler');
    },
    handleMouseUp: function() {
        alert('mouse up handler');
    }
};
LIB_addEventListener(document.body, 'mousedown', obj, 'handleMouseDown');
LIB_addEventListener(document.body, 'mouseup', obj, 'handleMouseUp');
</code></pre>

<p>This API still allows for listener <em>functions</em> by looking at the type of the third argument.</p>

<pre><code>LIB_addEventListener(document.body, 'mousedown', function() {
    alert('mousedown');
});
</code></pre>

<p>But now there is no need for specifying the <code>this</code> object that will be used when the listener <em>function</em> is called because we have something better suited to the task: listener <em>objects</em>.</p>

"))) ("Scheme from Scratch - Royal Scheme v0.1 - Integers" "<p>It took a while but the plan is back on track. Royal Scheme is a go.</p>
<p>I&rsquo;ve been picking away at the project at a leisurely pace trying to determine exactly what it will be. Blog articles seem like a great way to keep folks informed about the state of development. Hopefully some folks will want to follow along creating their own implementations again like they did with Bootstrap Scheme. It was a whole bunch of fun.</p>
<p>I think a book format would be a better format for truly documenting the iterative development of a real Scheme interpreter that is implemented in C. I still haven&rsquo;t found that book and if I was taking a university course then I&rsquo;d want to take the course that has that book as its primary text. So a lot of what Royal Scheme development will be about is ensuring the order of introducing features is just right and that the concepts underlying the implementation are explained in code comments and in a book. It is a lofty goal. We&rsquo;ll see how it goes. I&rsquo;m hoping for feedback from you.</p>
<p>Just as Bootstrap Scheme started with integers, so does Royal Scheme.</p>
<pre><code>$ ./scm
Welcome to Royal Scheme. Ctrl-c to exit.
> 123
123
> -123
-123
> +007
7
> ^C
$</code></pre>
<p>I&rsquo;ve put the code on github. I&rsquo;m new to git and github which adds a bit more flavor to the project. You can browse the code at the following address</p>
<p><a href=\"http://github.com/petermichaux/royal-scheme\">http://github.com/petermichaux/royal-scheme</a></p>
<p>and I created a branch specifically for this integers-only version</p>
<p><a href=\"https://github.com/petermichaux/royal-scheme/tree/v0.1\">https://github.com/petermichaux/royal-scheme/tree/v0.1</a></p>
<p>You can get the code with the following command</p>
<pre><code>$ git clone https://github.com/petermichaux/royal-scheme.git</pre></code>
<p>You should be able to just run <code>make</code> and then the above REPL session example should work.</p>
<p>I&rsquo;m hoping you will scrutinize the code and really give me grief that I&rsquo;ve done something silly, stupid, overly complex, have a trailing space on a line, haven&rsquo;t written a comment where a comment would be helpful, etc. I&rsquo;m particularly interested in what you think of checking the return value of <code>printf</code> and <code>scm_write</code> in <code>repl</code>. It doesn&rsquo;t feel right quite to me. Also the overflow checking in <code>scm_read_number</code> happens each iteration which is not as efficient as it possibly could be.</p>
<p>By the way, registration for the <a href=\"http://scheme2011.ucombinator.org/\">Scheme 2011 Workshop</a> will open in August. I&rsquo;m planning on going and hoping to talk with some people there about Royal Scheme.</p>
<p>
Previous article: <a href=\"/articles/scheme-from-scratch-royal-scheme-planning\">Introduction</a><br>
</p>" "/articles/scheme-from-scratch-royal-scheme-v0_1-integers" (20018 62152) old 7 nil nil ((id nil "http://peter.michaux.ca/articles/scheme-from-scratch-royal-scheme-v0_1-integers") (title nil "Scheme from Scratch - Royal Scheme v0.1 - Integers") (updated nil "2011-07-29T17:50:00Z") (link ((href . "/articles/scheme-from-scratch-royal-scheme-v0_1-integers") (rel . "alternate") (type . "text/html"))) (content ((type . "html")) "<p>It took a while but the plan is back on track. Royal Scheme is a go.</p>

<p>I&rsquo;ve been picking away at the project at a leisurely pace trying to determine exactly what it will be. Blog articles seem like a great way to keep folks informed about the state of development. Hopefully some folks will want to follow along creating their own implementations again like they did with Bootstrap Scheme. It was a whole bunch of fun.</p>

<p>I think a book format would be a better format for truly documenting the iterative development of a real Scheme interpreter that is implemented in C. I still haven&rsquo;t found that book and if I was taking a university course then I&rsquo;d want to take the course that has that book as its primary text. So a lot of what Royal Scheme development will be about is ensuring the order of introducing features is just right and that the concepts underlying the implementation are explained in code comments and in a book. It is a lofty goal. We&rsquo;ll see how it goes. I&rsquo;m hoping for feedback from you.</p>

<p>Just as Bootstrap Scheme started with integers, so does Royal Scheme.</p>

<pre><code>$ ./scm
Welcome to Royal Scheme. Ctrl-c to exit.
> 123
123
> -123
-123
> +007
7
> ^C
$</code></pre>

<p>I&rsquo;ve put the code on github. I&rsquo;m new to git and github which adds a bit more flavor to the project. You can browse the code at the following address</p>

<p><a href=\"http://github.com/petermichaux/royal-scheme\">http://github.com/petermichaux/royal-scheme</a></p>

<p>and I created a branch specifically for this integers-only version</p>

<p><a href=\"https://github.com/petermichaux/royal-scheme/tree/v0.1\">https://github.com/petermichaux/royal-scheme/tree/v0.1</a></p>

<p>You can get the code with the following command</p>

<pre><code>$ git clone https://github.com/petermichaux/royal-scheme.git</pre></code>

<p>You should be able to just run <code>make</code> and then the above REPL session example should work.</p>

<p>I&rsquo;m hoping you will scrutinize the code and really give me grief that I&rsquo;ve done something silly, stupid, overly complex, have a trailing space on a line, haven&rsquo;t written a comment where a comment would be helpful, etc. I&rsquo;m particularly interested in what you think of checking the return value of <code>printf</code> and <code>scm_write</code> in <code>repl</code>. It doesn&rsquo;t feel right quite to me. Also the overflow checking in <code>scm_read_number</code> happens each iteration which is not as efficient as it possibly could be.</p>

<p>By the way, registration for the <a href=\"http://scheme2011.ucombinator.org/\">Scheme 2011 Workshop</a> will open in August. I&rsquo;m planning on going and hoping to talk with some people there about Royal Scheme.</p>

<p>
  Previous article: <a href=\"/articles/scheme-from-scratch-royal-scheme-planning\">Introduction</a><br>
</p>

"))) ("JavaScript is Dead. Long Live JavaScript!" "<p>For 16 years, JavaScript has been the language of the web browser. This language has enabled the building of compelling web applications and contributed to the success of the web. Other scripting languages could have filled the role JavaScript does but JavaScript was in the right place at the right time. Microsoft added Basic to Internet Explorer a long time ago but JavaScript was the language in all the browsers and so it won. Since JavaScript has been cross-browser and at least good enough, the browser makers have not needed to add other language interpreters to the browsers themselves.</p>
<p>But we still didn&rsquo;t choose to use JavaScript. It has been the one option. It has powerful features like closures and we learned to love these features while turning a blind eye to the warty parts of the language. There has even been a lot of apologizing to the programming community along the lines of &ldquo;Yes we know it is a pretty funky language but please give it a chance. I&rsquo;m sure you&rsquo;ll learn to love it.&rdquo; It shouldn&rsquo;t be that hard to sell the quality of the language. JavaScript has been described as an experiment that escaped the lab a little too early and we&rsquo;ve been stuck with the warts ever since.</p>
<p>Still, JavaScript has been a great language. In 2007, Steve Yegge declared JavaScript as <a href=\"http://steve-yegge.blogspot.com/2007/02/next-big-language.html\">The Next Big Language</a> and it has been. Between then and now JavaScript-based web-applications have become bigger and better. With JavaScript&rsquo;s help, the web has continued to flourish even with the threat of native mobile apps taking over the same space.</p>
<p>In very recent times, JavaScript has been making its most successful attempt at being a server-side language. The Node.js platform, with its non-blocking I/O, may be solving a problem that programmers have needed solved for a long time. JavaScript is the language for Node.js and so JavaScript may go along for the ride to become a successful server-side language after many failed attempts in the past.</p>
<p>Overall, JavaScript has been a wild success. The most popular programming language in the world. But if the browser died today, how much new JavaScript code would be written tomorrow? Most likely JavaScript would become a fringe language overnight. But the browser isn&rsquo;t dying tomorrow. We will be programming for it for years to come.</p>
<p>As JavaScript has been used for more and larger programs, the warts of the language have become more apparent and caused increasing amounts of grief for many developers. It may come as a surprise that even though I&rsquo;ve written about JavaScript for years, I&rsquo;m not a JavaScript fanboy. Most of my JavaScript articles have been about me working through the difficulties of finding a peaceful coexistence with the language. Yes I&rsquo;ve enjoyed programming in JavaScript and have learned a lot but there certainly have been times when I&rsquo;ve felt like I&rsquo;m wallowing in the muck.</p>
<p>One of the most obvious deficiencies in JavaScript is with its user interface: its syntax. The inability to quickly improve its syntax has lead to the language&rsquo;s downfall.</p>
<h2>The Case for Syntax Extensions: Verbose Idioms</h2>
<p>Here we look at just four of the many examples where JavaScript&rsquo;s syntax could be improved to remove verbose idioms from our daily programming existences.</p>
<h3>Optional Parameters and Default Values</h3>
<p>JavaScript functions can be called with a variable number of actual parameters. This makes some of the formal parameters in the function&rsquo;s declaration optional. Often times these optional parameters must be set to a default value if no actual parameter is supplied. I&rsquo;m willing to bet you&rsquo;ve written and seen plenty of code like the following.</p>
<pre><code>function(a, b, option) {
option = option || {};
// ...
}</code></pre>
<p>I have and still write code like this. This code is wrong. If a falsy value is passed to the function for <code>option</code> then the wrong thing happens. We should be writing the following.</p>
<pre><code>function(a, b, option) {
option = arguments.length &gt; 2 ? option : {};
// ...
}</code></pre>
<p>Although this code expresses the intended thought of setting a default value if an actual parameter for <code>option</code> is not supplied, it is too verbose and less readable. The reader must count to determine which variable is has index 2. Beyond the awkwardness, the correct version is more difficult to maintain. It is easy to produce the following buggy code if the <code>b</code> parameter is removed.</p>
<pre><code>function(a, option) {
option = arguments.length &gt; 2 ? option : {};
// ...
}</code></pre>
<p>If your application uses optional parameters with default values, some new syntax would be beneficial for you.</p>
<pre><code>function(a, b, option = {}) {
// ...
}</code></pre>
<p>The addition of this new syntax tunes the language better to your application&rsquo;s needs.</p>
<h3>Let</h3>
<p>Does the following buggy code look familiar?</p>
<pre><code>for (var i=0, ilen=elements.length; i&lt;ilen; i++) {
var element = elements[i];
LIB_addEventListener(element, 'click', function(event) {
alert('I was originally number ' + i);
});
}</code></pre>
<p>All the elements were the same number?! The solution is to use an immediately evaluated function expression so each alert reports a different number. This is the &ldquo;let&rdquo; idiom after Lisp&rsquo;s various <code>let</code> forms.</p>
<pre><code>for (var i=0, ilen=elements.length; i&lt;ilen; i++) {
var element = elements[i];
(function(num) {
LIB_addEventListener(element, 'click', function(event) {
alert('I was originally number ' + num);
});
}(i));
}</code></pre>
<p>Sure sometimes delegate listeners might be better than the above code but sometimes the above code is the desired idea. In the above case, we are trying to bind the order of the elements when the loop runs. This order could be lost with the delegate pattern if the elements are rearranged in the DOM.</p>
<p>This syntax is particularly awkward because of the distance between the formal <code>num</code> and actual <code>i</code> parameters of the immediate function.</p>
<p>The immediate function could be factored out to another location and called inside the loop.</p>
<pre><code>function attachListener(element, num) {
LIB_addEventListener(element, 'click', function(event) {
alert('I was originally number ' + num);
});
}
for (var i=0, ilen=elements.length; i&lt;ilen; i++) {
attachListener(elements[i], i);
}</code></pre>
<p>Even with this option, sometimes programmers still use the immediate function because it conveys better their intended message to readers.</p>
<p>If your application uses the let idiom, wouldn&rsquo;t it be nice to have new syntax for it?</p>
<pre><code>for (var i=0, ilen=elements.length; i&lt;ilen; i++) {
var element = elements[i];
let (num = i) {
LIB_addEventListener(element, function(event) {
alert('I was originally number ' + num);
});
};
}</code></pre>
<p>With <code>num</code> and <code>i</code> together it is much easier to read this code and a new scope containing <code>new</code> has been introduced so the closure works properly. Once again, the addition of new syntax can tune the language better to your application&rsquo;s needs.</p>
<h3>Modules</h3>
<p>One of the most common idioms in JavaScript programs we all know and love is usually called &ldquo;the module pattern.&rdquo; This idiom provides the benefits of encapsulated variables that are private to the module and imparts sanity to our code.</p>
<pre><code>var event = (function() {
// private variables
var listeners = [];
function addEventListener(f) {
listeners.push(f);
}
function clearEventListeners() {
listeners = [];
}
// ...
// export the module's API
return {
addEventListener: addEventListener,
clearEventListeners: clearEventListeners
// ...
};
}());</code></pre>
<p>The goal of encapsulation here isn&rsquo;t security. It is to ensure that other developers keep their dirty, monkey-patching hands off your module&rsquo;s data.</p>
<p>The exporting can be done a few ways but no matter which way there is some boiler plate.</p>
<p>Importing is verbose also</p>
<pre><code>(function() {
// import desired properties of the event module
var addEventListener = event.addEventListener;
var clearEventListeners = event.clearEventListeners;
// ...
}());</code></pre>
<p>Some new syntax would be nice to convey the intent of the module pattern better.</p>
<pre><code>module event {
// private variables
var listeners = [];
export function addEventListener(f) {
listeners.push(f);
}
export function clearEventListeners() {
listeners = [];
}
// ...
}</code></pre>
<pre><code>(function() {
import event;
// ...
}());</code></pre>
<p>The module pattern is almost everywhere and some new syntax to better express this idiom would better tune the language to all of our applications.</p>
<h3>Inheritance</h3>
<p>These idiom examples have been growing in how they each span an increasing number of lines of code. The JavaScript idiom that potentially spans the most lines of your program may be the inheritance idiom.</p>
<pre><code>function Employee(first, last, position) {
// call the superclass constructor
Person.call(this, first, last);
this.position = position;
};
// inherit from Person
Employee.prototype = Object.create(Person.prototype);
Employee.prototype.constructor = Employee;
// define an overridding toString() method
Employee.prototype.toString = function() {
// call superclass's overridden toString() method
return Person.prototype.toString.call(this) +
' is a ' + this.position;
};</code></pre>
<p>What a mess. Yes JavaScript makes single inheritance like this possible by linking prototypes but it takes a lot of code to manually make super things happen they way you might like inheritance to work.</p>
<p>If there could be a maintenance nightmare that is it. The strings &ldquo;Person&rdquo; and &ldquo;Employee&rdquo; are sprawled throughout the code for the Employee &ldquo;class&rdquo;.</p>
<p>If classes with inheritance are a big part of your application, some syntax would really help clean up the code. Perhaps something like the following.</p>
<pre><code>class Employee extends Person {
constructor(first, last, position) {
super(first, last);
public position = position;
}
update(camera) {
return super.update() + ' is a ' + position;
}
}</code></pre>
<p>That is a major improvement.</p>
<h3>Learning from Idioms</h3>
<p>These common idioms make it clear that JavaScript could use some new syntax for several reasons. The ability to do what we want is usually in JavaScript somewhere. The verbosity of the idioms is sometimes too much. We cut corners. Sometimes we avoid certain algorithms because the idioms are too verbose. The idioms are not self explanatory. They are inside secrets of the community and the intent is not easily recognized by outsiders.</p>
<p>The ECMAScript committee has recognized that the above idioms, and others idioms, are common across a wide variety of applications. There are proposals for all of these syntax cases in Harmony. Some of them may make it into the next version of ECMAScript and into the browsers for your use. If new syntax gets there eventually then you can use use it.</p>
<p>Idioms may have emerged in <em>your</em> application that do not appear in a wide variety of applications. For example, Node.js&rsquo;s non-blocking I/O and heavy reliance on callbacks will undoubtedly result in idioms that do not appear in browser scripts. Syntax specific to just your applications will likely never make it into ECMAScript.</p>
<p>If you would like to use specialized syntax for the general idioms like those shown above or you would like syntax for your own idioms, what can you do?</p>
<h2>If Only We Had Macros</h2>
<p>Lisp languages have had full-blown macros for decades. Through macros, Lisp gives programmers the ability to tune the language&rsquo;s syntax to best match their own applications. Because of its macros, Lisp has been described as &ldquo;the programmable programming language.&rdquo; Powerful stuff.</p>
<p>Lisp&rsquo;s s-expression syntax, you know, the syntax with all those parens, gives the language a special property called homoiconicity. It roughly means the syntax of the language is also the syntax of its data structures or that a program&rsquo;s parse tree uses the languages data structures. This homoiconicity makes Lisp&rsquo;s macros possible.</p>
<p>JavaScript doesn&rsquo;t have macros. A major reason for this is that adding macros to languages with C-like syntax, languages that are not homoiconic, is still a research topic. Excerpts from a short conversation on Twitter with littlecalculist, Dave Herman, Ph.D., ECMAScript committee member, and Mozilla Researcher:</p>
<blockquote>
<dl>
<dt>@petermichaux</dt>
<dd>I believe @littlecalculist knows more about the research and possibilities for macros in ECMAScript. I&rsquo;d like to know more also.</dd>
<dt>@littlecalculist<dt>
<dd>I have thoughts on it for sure. But macros for non-sexp languages is still very much a challenging research topic</dd>
<dt>@petermichaux<dt>
<dd>[...] We&rsquo;ll turn blue waiting for macros.</dd>
<dt>@littlecalculist<dt>
<dd>Might I suggest you keep breathing? ;-) Seriously, I do hope to try, but trust me, macro system design is hard.</dd>
</dl>
</blockquote>
<p>The message is pretty clear. JavaScript macros are not just around the corner.</p>
<h2>Harmony Syntax ETA</h2>
<p>Perhaps the syntax extensions in Harmony are all you dream of and more. If Harmony becomes ECMAScript&nbsp;6 and ECMAScript&nbsp;6 becomes ubiquitous then you&rsquo;ll be all set. So all you need to do is wait...patiently.</p>
<p>First, let&rsquo;s look at browser adoption. Unfortunately I&rsquo;ll pick on Internet Explorer a bit, which has almost become a cliche, but not because I have something against the Internet Explorer development team at Microsoft or the newest versions of Internet Explorer. It is necessary to look at this browser because it is perhaps the most important case study for estimating when features will be available for all visitors to your web site.</p>
<p>As of May 2011, <a href=\"http://www.w3schools.com/browsers/browsers_stats.asp\">w3schools</a>, which has relatively tech-savvy visitors, reports Internet Explorer&nbsp;6 still has 2.4% market share. <a href=\"http://marketshare.hitslink.com/browser-market-share.aspx?spider=1&amp;qprid=2\">Net Market Share</a> reports Internet Explorer&nbsp;6 still has 10.36% market share. Your site probably has a market share somewhere between those two numbers but this browser is still hanging on even though it was superseded by Internet Explorer&nbsp;7 in November 2006. How many people are still using Internet Explorer&nbsp;6 or 7? The w3schools site shows 7.7% and Net Market Share shows 18.2%. These browsers just aren&rsquo;t going away fast enough. A publicly available site (e.g. Amazon) cannot afford to ignore market share numbers this large.</p>
<p>There is no point in spending any energy moaning that users should upgrade their browsers or that &ldquo;IE should die!&rdquo; It won&rsquo;t happen. I don&rsquo;t know if it is true but someone once said to me &ldquo;Internet Explorer users upgrade their browser when they upgrade their hardware.&rdquo; For the past few years, hardware has certainly become sufficient that people don&rsquo;t need to upgrade anything to use email, Facebook, Twitter, etc.</p>
<p>Suppose your web app is sufficiently advanced that you&rsquo;ve decided that you only care about users with &ldquo;modern&rdquo; browsers. Google Apps recently announced that on August 1, 2011 they will stop supporting Internet Explorer&nbsp;7. That is almost 5 years after Internet Explorer&nbsp;7 was released.</p>
<p>Now think about this: Internet Explorer&nbsp;10 is not out yet but, of course, even it won&rsquo;t have Harmony&rsquo;s syntax extensions. Let&rsquo;s estimate that Harmony is approved as ECMAScript&nbsp;6 in mid-2012 and Internet Explorer&nbsp;11 is released in early 2013 with support for all of Harmony&rsquo;s syntax. Five years after that, in 2018, the Google Apps team can drop support for Internet Explorer&nbsp;11 and finally use Harmony syntax freely. (On August 1, 2011, they are also dropping support for the four-year-old Safari&nbsp;3 and two-year-old Firefox&nbsp;3.5 so the waits are still long-ish for other browsers too.)</p>
<p>Amazon developers might need to wait an additional 5&nbsp;years before they can use Harmony syntax. That&rsquo;s 2023!</p>
<p>Will you be satisfied waiting 7-12&nbsp;years before you can start using syntax that would be helpful developing your web apps today? Being more optimistic, even if the wait is just 5&nbsp;years, will you wait?</p>
<h2>JavaScript is Dead.</h2>
<p>Cause of death: semicolon cancer.</p>
<p>Perhaps due to JavaScript&rsquo;s syntax alone, JavaScript does not have macros now and won&rsquo;t have them soon if ever. Millions of programmers use JavaScript now and plenty of them are tired or tiring of the verbose idioms confronting them daily. They want new syntax now and won&rsquo;t wait. For this growing group of developers, JavaScript the source code language is dead.</p>
<p>You had a good reign, JavaScript. We had some good times and wrote some cool apps together. May you rest in peace.</p>
<h2>Long Live JavaScript!</h2>
<p>Programmers like to control their own destiny and they are taking action. You can have all the new syntax you want for your browser scripts, right now, if you write in another source language and compile to the ECMAScript&nbsp;3 dialect of JavaScript for the billions of browsers in the wild. By compiling to ECMAScript&nbsp;3 you are completely freed from JavaScript&rsquo;s syntactic evolution. As an added bonus, you can even <em>fix</em> some of JavaScript&rsquo;s semantic gotchas with a sufficiently sophisticated compiler. JavaScript&rsquo;s new life is as a compilation target.</p>
<h2>Languages that Compile to JavaScript</h2>
<p>There have been compilers to JavaScript for years now. In 2007, I started collecting a list of languages with compilers to JavaScript. There were JavaScript extension languages: the now-defunct ECMAScript&nbsp;4, Narrative JavaScript, and Objective-J. There were pre-existing languages: Scheme, Common Lisp, Smalltalk, Ruby, Python, Java, C#, Haskell, etc. There were even brand new languages HaXe, Milescript, Links, Flapjax that were designed to address web programming needs.</p>
<p>Of these compiler projects, Google&rsquo;s GWT Java-to-JavaScript compiler has probably been the most successful but I don&rsquo;t see programmers who first learned a language other than Java rushing to use Java as their source code language. In fact, none of these compiler projects have accrued a significant long-term user base. At least in the parts of the web that I frequent, with the exception of GWT, it is rare to read about programmers using these compilers for any real projects. There are several legitimate reasons not to use one of these compilers.</p>
<p>Imagine you build a big project using one of these compilers and part way through find a bug in the compiler. The one maintainer of the compiler may have lost interest or time. Do you want to maintain a compiler? Does anyone on your team have the skills to do that? That ulcer is going to get pretty big while you prepare to explain to the CEO that you now need to rewrite the UI in JavaScript.</p>
<p>Just the thought of debugging compiled code when a production bug is filed makes my stomach churn. Core dump. What line number in the source code matches the line number Firebug is reporting for the compiled code? HURRY! That bug needs to be fixed now!!!!</p>
<p>You&rsquo;ve used Objective-J for a big project and now you need to hire a new good programmer. What are your chances of finding the right person? They are probably very low. Just finding an available JavaScript programmer is difficult enough. If you use one of these alternate languages, it is very likely you&rsquo;ll need to train each new person you add to your team.</p>
<p>Even without these compiler projects being wildly successful, the list of languages that compile to JavaScript has continued to grow. There is no doubt that writing a to-JavaScript compiler is a very cool project. Please pay me to write one.</p>
<p>There is one notable new entry in the list of languages that compile to JavaScript that is actually causing a big stir and is possibly changing the game for good.</p>
<h3>CoffeeScript</h3>
<p>I can tell you right now, I don&rsquo;t know why CoffeeScript has the magic combination of features to garner the attention it has when other projects have failed. Significant whitespace and arrow function syntax. My gut reaction is yuck. There is plenty of things to like: default parameter values, rest parameters, spread, destructuring, fixing the whole implied global mess, even classes if you&rsquo;re into that kind of thing and more. Many of CoffeeScript&rsquo;s features are part of Harmony and so may be in browsers sometime in the future but if you use CoffeeScript then you can have them now. There is nothing like instant gratification.</p>
<p>Programmers are bursting with affection for CoffeeScript.</p>
<blockquote>
<dl>
<dt>@pyronicide</dt>
<dd>Being able to use default values for function arguments in #coffeescript makes me immensely happy.</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>@_jdpage</dt>
<dd>CoffeeScript is wonderful. Now I am spoiled and will complain whenever I have to write JavaScript instead.</dd>
</dl>
</blockquote>
<p>At the TXJS 2011 conference, Douglas Crockford apparently shared that he thinks &ldquo;CoffeeScript is clearly good stuff.&rdquo;</p>
<p>There is one aspect of the CoffeeScript project that I really like and it is summed up by the following two quotations. The first comes from Trevor Burnham, author of <a href=\"http://pragprog.com/titles/tbcoffee/coffeescript\">CoffeeScript: Accelerated JavaScript Development</a>.</p>
<blockquote>
<dl>
<dt>@trevorburnham</dt>
<dd>[...] It&rsquo;s not about turning JS into Ruby/Python; it&rsquo;s about having a syntax better suited to JavaScript&rsquo;s inner goodness.</dd>
</dl>
</blockquote>
<p>The second is from <a href=\"http://arcturo.com/library/coffeescript/00_introduction.html\">The Little Book on CoffeeScript</a>.</p>
<blockquote>
<p>CoffeeScript neatly sidesteps these [JavaScript issues], by only exposing a curated selection of JavaScript features.</p>
</blockquote>
<p>The attitude expressed in these quotations really is great and genius marketing too. It is not CoffeeScript verse JavaScript. It is CoffeeScript enhancing the JavaScript programming experience. Could some different syntax and a restricted subset of JavaScript&rsquo;s features really be better than plain old JavaScript?</p>
<p>Douglas Crockford seems to think so. For years, his <a href=\"http://jslint.com/\">JSLint</a> has been hurting our feelings and demanding that we use very specific whitespace and syntax and that we avoid dangerous JavaScript features. Source code that passes JSLint has access to a true subset of JavaScript: the subset that he calls &ldquo;the good parts.&rdquo; This dialect of JavaScript deserves a name. Maybe GoodScript? After all, you are only allowed to use JSLint for good and not for evil.</p>
<p>The ECMAScript committee also thinks this is a good idea. The <code>\"use strict\"</code> pragma introduced in ECMAScript&nbsp;5 not only restricts some language features like <code>with</code>, strict mode even changes/fixes the semantics of some parts of the language. Because of the semantic changes, ECMAScript&nbsp;5 strict is a different language or at least a different dialect than ECMAScript&nbsp;5 non-strict.</p>
<p>CoffeeScript, GoodScript, and ECMAScript&nbsp;5 strict share common goals of keeping you away from the dangerous parts of JavaScript while giving you access to the valuable, safe parts. Each enforces these goals differently but they are enforced one way or another. You don&rsquo;t get new syntax with GoodScript. It is already JavaScript and ready for the browser. You don&rsquo;t get to use ECMAScript&nbsp;5 strict because it is not available in all browsers yet and won&rsquo;t be for years.</p>
<p>So CoffeeScript seems to be targeting a particular need of web development and maybe that is something other to-JavaScript compilers haven&rsquo;t done or haven&rsquo;t done well before.</p>
<p>CoffeeScript is also a reasonably thin skin over JavaScript. One consequence of this is that the compiled JavaScript code is reasonably easy to read and not brutal to debug (so I&rsquo;m told.) This reduced debugging fear is contributing to interest in CoffeeScript.</p>
<p>CoffeeScript almost feels like a set of macros for writing JavaScript programs.</p>
<p>Since CoffeeScript compilers are in the hands of developers rather than the visitors to sites, you control which version of CoffeeScript you are using. You can upgrade at will. This also means CoffeeScript does not need to be standardized and go through the subsequent painfully slow growth of a standardized language. CoffeeScript can grow at the rate of its community&rsquo;s imagination and desire. JavaScript standardization was essential to the success of the web but the same constraints do not apply to CoffeeScript.</p>
<h2>Well then I&rsquo;m going to invent my own language.</h2>
<p>You can do this and it would be a great exercise. You&rsquo;ll be able to call yourself a compiler writer which is pretty darned prestigious.</p>
<p>The danger of inventing your own language lies in the thinking that you can do better than JavaScript has done <strong>in the long run</strong>. Language design is hard and I bet your language will grow its share of unsightly hairs. Maybe not as many hairs as JavaScript but still. CoffeeScript hasn&rsquo;t hit puberty yet but there are already signs that hair follicles may exist.</p>
<blockquote>
<dl>
<dt>@maxsamukha</dt>
<dd>CoffeeScript: The way variables in outer scopes can be accidentally overwritten is fishy. How bad is it in practice?</dd>
</dl>
</blockquote>
<p>You were so proud that your simple, readable compiled code was easy to debug. That will become harder as you realize the compiled code&rsquo;s semantics aren&rsquo;t quite what they were supposed to be in corner cases.</p>
<p>Idioms will appear in your language and someone will fork your compiler to do away with those idioms (unless your language happens to have macros.)</p>
<p>Enough with this nay saying. Go and write your own language right now. You&rsquo;ll be a better programmer for it.</p>
<h2>What&rsquo;s missing from JavaScript the target language?</h2>
<p>JavaScript is embarking on a new life as a compilation target. It is a capable target for many language features but it could use improvement. In his <a href=\"http://brendaneich.com/2011/05/my-jsconf-us-presentation/\">JSConf.US talk</a>, Brendan Eich stated that one the goals for Harmony is to be a better target for to-JavaScript compilers.</p>
<p>Compiled JavaScript can run slower than hand-written JavaScript just like compiled C can be slower than hand-written Assembly (though not always.) Some inefficiency in compiled JavaScript is tolerable because JavaScript virtual machines are fast and the DOM is the bottleneck anyway. That said, some potential source code languages have semantics sufficiently far from JavaScript&rsquo;s semantics that the compiled code is so inefficient that it cannot realistically be used in production web apps. There are already features in Harmony that will enable some of these languages to be compiled to efficient code and thus make these viable source code languages.</p>
<h3>Proper Tail Calls</h3>
<p>Programs in Lisp languages depend heavily on recursive calls to properly tail recursive procedures. The <a href=\"http://wiki.ecmascript.org/doku.php?id=harmony:proper_tail_calls&amp;s=const\">proper tail calls</a> proposal in Harmony will allow these programs to be compiled to JavaScript without the inefficient trampoline technique currently necessary to avoid overflowing the call stack. Awesome! Let&rsquo;s look at that in a bit more detail.</p>
<p>The following JavaScript is an example of mutually recursive functions which would work fine in Lisp but since JavaScript currently does not have proper tail calls, will overflow the JavaScript call stack when <code>number</code> is large.</p>
<pre><code>function isEven(number) {
if (number === 0) {
return true;
}
else {
return isOdd(number - 1);
}
}
function isOdd(number) {
if (number === 0) {
return false;
}
else {
return isEven(number - 1);
}
}
isEven(100000); // InternalError: too much recursion</code></pre>
<p>In the above code, a call to <code>isEven(100000)</code> isn&rsquo;t complete and removed from the call stack until <code>isOdd(99999)</code> returns which isn&rsquo;t complete and removed from the call stack until <code>isEven(99998)</code> returns and so on. That&rsquo;s a lot of calls on the call stack! And there is no need for them all to be on the call stack. <code>isEven(100000)</code> doesn&rsquo;t have anything intelligent remaining to do once it calls <code>isOdd(99999)</code> because the call to <code>isOdd(99999)</code> is the very last thing in <code>isEven(100000)</code>. The call is said to be in tail position. <code>isEven(100000)</code> is just waiting to return the value returned by <code>isOdd(99999)</code> and a clever language can just pop <code>isEven(100000)</code> off the call stack and replace it with the call to <code>isOdd(99999)</code> thus saving space on the call stack.</p>
<p>With trampolines we can ensure that even in JavaScript the call stack doesn&rsquo;t grow large. The following is just a sketch of how trampolines might be implemented and how <code>isEven</code> and <code>isOdd</code> might be compiled for a JavaScript interpreter that doesn&rsquo;t have proper tail calls.</p>
<pre><code>function bounce(ret) {
while (typeof ret === 'function') {
ret = ret();
}
return ret;
}
function isEven(number) {
if (number === 0) {
return true;
}
else {
return function() {
return isOdd(number - 1);
};
}
}
function isOdd(number) {
if (number === 0) {
return false;
}
else {
return function() {
return isEven(number - 1);
};
}
}
bounce(function() {return isEven(100000);}); // true</code></pre>
<p>You can see the extra overhead of the <code>bounce</code> function which implements the trampoline calls is quite onerous. It creates closures for each continuation, doubles the number of calls, and must examine the returned value after each bounce; however, <code>isEven(10000)</code> does complete and is removed from the callstack <em>before</em> <code>isOdd(99999)</code> is called. The full computation completes in constant call stack space.</p>
<p>The bottom line is trampolines incur too much overhead. They incur so much overhead that when Rich Hickey created Clojure, his Lisp for the JVM, he decided his language could not have proper tail calls because trampolines were too expensive. That must have been a painful decision for someone who loves the Lisp family of languages.</p>
<p>The good news is that the ECMAScript committee has recognized this deficiency in JavaScript and has added proper tail calls to Harmony. This will benefit programmers writing directly in JavaScript and developers of to-JavaScript compilers.</p>
<h3>Lambdas</h3>
<p>Another strawman proposal not yet promoted to Harmony is the <a href=\"http://wiki.ecmascript.org/doku.php?id=strawman:block_lambda_revival\">Block Lambda Revival</a> which combines some new syntax with a new language construct called a lambda. A lambda is a callable thing, like a function, but it obeys Tennent&rsquo;s Correspondence Principle. Tennent&rsquo;s Correspondence Principle states that wrapping an expression or block of code in an immediate lambda should not change the meaning of that wrapped code. JavaScript functions are not lambdas and do not obey Tennent&rsquo;s Correspondence Principle. For example,</p>
<pre><code>function one() {
return 1;
}
one(); // 1</code></pre>
<p>is not the same when the return line is wrapped in an immediate function</p>
<pre><code>function one() {
(function() {
return 1;
}());
}
one(); // undefined</code></pre>
<p>The syntax of the block lambda proposal for a lambda that takes two arguments and sums them is <code>{|a,&nbsp;b|&nbsp;a&nbsp;+&nbsp;b}</code></p>
<p>Using the syntax of the block lambda proposal  we can wrap the return line in an immediate lambda without changing the meaning.</p>
<pre><code>function one() {
({||
return 1;
}());
}
one(); // 1</code></pre>
<p>Thanks to lambdas obeying Tennent&rsquo;s Correspondence Principle, the <code>return</code> still means return from the function <code>one</code>.</p>
<p>You may ask &ldquo;Who cares about this computer science-y stuff?&rdquo; to which I reply &ldquo;Did any of that macro business seem useful?&rdquo; because lambdas are a fundamental building block in the code generated by many macros. And since lambdas play nicely with JavaScript&rsquo;s <code>return</code>, <code>arguments</code>, and <code>this</code>, lambdas would be a valuable addition to the language for compiler writers.</p>
<p>I&rsquo;m focusing on the JavaScript-as-a-target aspect of the block lambda proposal. If you plan on writing in JavaScript forever after, the proposal has other benefits for you too that don&rsquo;t matter to compiler writers.</p>
<p>The block lambda strawman has not yet been promoted to Harmony and so currently doesn&rsquo;t have a path into ECMAScript&nbsp;6 and browsers around the world. The standardization process is slow. Maybe there will be another decade stall in evolving the language like there was after ECMAScript&nbsp;3. Maybe the next edition of ECMAScript will be the last edition. Better to get the best stuff in there than hope to get it in later. If you care about the future of JavaScript and think lambdas would be a benefit to the language then <strong>let the ECMAScript committee know by sending a message to the <a href=\"https://mail.mozilla.org/listinfo/es-discuss\">es-discuss mailing list</a> in support of the block lambda proposal</strong>. Powerful, orthogonal language features like tail calls and lambdas which have no efficient workarounds may be the most important additions in the next edition of ECMAScript.</p>
<h2>What&rsquo;s missing from the browser?</h2>
<p>The browser can help JavaScript succeed in its new life as a compilation target. The browser interprets compiled JavaScript and complains when the compiled code has an error. The error messages contain line numbers in the compiled code but you want to know the line number in source code.</p>
<p>The Mozilla crowd has <a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=618650\">an open ticket</a> and <a href=\"https://wiki.mozilla.org/DevTools/Features/SourceMap\">a dev tools project</a> to ease debugging source code by mapping compiled code lines to source code lines. Since you control the browser in which you primarily develop and test, you can use this feature as soon as it is ready.</p>
<p>Somewhere I read that the Webkit folks are developing similar source code debugging assistance but I cannot find any concrete evidence.</p>
<h2>Polyglot</h2>
<p>JavaScript&rsquo;s monopoly in the browser has meant front-end programmers all speak the same language. This has given the community a <i>lingua franca</i> enabling good communication and code sharing. We are now headed for a polyglot future where you choose the language(s) you want to learn and use for developing browser applications. Maybe you are only using a few JavaScript language extensions via <a href=\"http://code.google.com/p/traceur-compiler/\">Traceur</a> and compiling templates to JavaScript with <a href=\"http://mustache.github.com/\">Mustache</a>. This still means that the CoffeeScript programmer won&rsquo;t understand your source code immediately.</p>
<p>This divergence was inevitable as it has happened on all previously successful platforms. There have been multiple languages for building native applications almost forever. C is still common but C++, Objective-C, and many other languages are available. The JVM was intended to run programs written in Java but clever developers have added other languages like Clojure and JRuby as options. Microsoft recognized what seems to be a human psychological need for a variety of languages and developed its .NET CLR platform for multiple languages from the beginning. Programs written in Basic, C#, IronPython, etc can all be run on the CLR.</p>
<p>Barriors to communication in the front-end community are not new anyway. A developer using Dojo cannot immediately understand the source code of an application written with jQuery or YUI. There is a plethora of libraries, some very different, that add the ideas of class-based inheritance to JavaScript. So we already have our barriors even within JavaScript.</p>
<p>Having multiple source languages will increase the barriers in our community. Programmers will still need to know JavaScript, at least for a while, but in a few years they may know other source languages better then they know JavaScript.</p>
<p>Choice is a blessing and a curse.</p>
<h2>Summary</h2>
<p>It is great having the opportunity to watch JavaScript&rsquo;s transition to a new life as it happens. It&rsquo;s impossible to say which languages will end up winning market share in the to-JavaScript compilation but it is sure to be interesting. CoffeeScript is gaining momentum now but I think many other successful source code languages will follow.</p>
<p>What do you think will happen?</p>" "/articles/javascript-is-dead-long-live-javascript" (19974 17196) old 8 nil nil ((id nil "http://peter.michaux.ca/articles/javascript-is-dead-long-live-javascript") (title nil "JavaScript is Dead. Long Live JavaScript!") (updated nil "2011-06-25T20:21:00Z") (link ((href . "/articles/javascript-is-dead-long-live-javascript") (rel . "alternate") (type . "text/html"))) (content ((type . "html")) "<p>For 16 years, JavaScript has been the language of the web browser. This language has enabled the building of compelling web applications and contributed to the success of the web. Other scripting languages could have filled the role JavaScript does but JavaScript was in the right place at the right time. Microsoft added Basic to Internet Explorer a long time ago but JavaScript was the language in all the browsers and so it won. Since JavaScript has been cross-browser and at least good enough, the browser makers have not needed to add other language interpreters to the browsers themselves.</p>

<p>But we still didn&rsquo;t choose to use JavaScript. It has been the one option. It has powerful features like closures and we learned to love these features while turning a blind eye to the warty parts of the language. There has even been a lot of apologizing to the programming community along the lines of &ldquo;Yes we know it is a pretty funky language but please give it a chance. I&rsquo;m sure you&rsquo;ll learn to love it.&rdquo; It shouldn&rsquo;t be that hard to sell the quality of the language. JavaScript has been described as an experiment that escaped the lab a little too early and we&rsquo;ve been stuck with the warts ever since.</p>

<p>Still, JavaScript has been a great language. In 2007, Steve Yegge declared JavaScript as <a href=\"http://steve-yegge.blogspot.com/2007/02/next-big-language.html\">The Next Big Language</a> and it has been. Between then and now JavaScript-based web-applications have become bigger and better. With JavaScript&rsquo;s help, the web has continued to flourish even with the threat of native mobile apps taking over the same space.</p>

<p>In very recent times, JavaScript has been making its most successful attempt at being a server-side language. The Node.js platform, with its non-blocking I/O, may be solving a problem that programmers have needed solved for a long time. JavaScript is the language for Node.js and so JavaScript may go along for the ride to become a successful server-side language after many failed attempts in the past.</p>

<p>Overall, JavaScript has been a wild success. The most popular programming language in the world. But if the browser died today, how much new JavaScript code would be written tomorrow? Most likely JavaScript would become a fringe language overnight. But the browser isn&rsquo;t dying tomorrow. We will be programming for it for years to come.</p>

<p>As JavaScript has been used for more and larger programs, the warts of the language have become more apparent and caused increasing amounts of grief for many developers. It may come as a surprise that even though I&rsquo;ve written about JavaScript for years, I&rsquo;m not a JavaScript fanboy. Most of my JavaScript articles have been about me working through the difficulties of finding a peaceful coexistence with the language. Yes I&rsquo;ve enjoyed programming in JavaScript and have learned a lot but there certainly have been times when I&rsquo;ve felt like I&rsquo;m wallowing in the muck.</p>

<p>One of the most obvious deficiencies in JavaScript is with its user interface: its syntax. The inability to quickly improve its syntax has lead to the language&rsquo;s downfall.</p>


<h2>The Case for Syntax Extensions: Verbose Idioms</h2>

<p>Here we look at just four of the many examples where JavaScript&rsquo;s syntax could be improved to remove verbose idioms from our daily programming existences.</p>


<h3>Optional Parameters and Default Values</h3>

<p>JavaScript functions can be called with a variable number of actual parameters. This makes some of the formal parameters in the function&rsquo;s declaration optional. Often times these optional parameters must be set to a default value if no actual parameter is supplied. I&rsquo;m willing to bet you&rsquo;ve written and seen plenty of code like the following.</p>

<pre><code>function(a, b, option) {
    option = option || {};
    // ...
}</code></pre>

<p>I have and still write code like this. This code is wrong. If a falsy value is passed to the function for <code>option</code> then the wrong thing happens. We should be writing the following.</p>

<pre><code>function(a, b, option) {
    option = arguments.length &gt; 2 ? option : {};
    // ...
}</code></pre>

<p>Although this code expresses the intended thought of setting a default value if an actual parameter for <code>option</code> is not supplied, it is too verbose and less readable. The reader must count to determine which variable is has index 2. Beyond the awkwardness, the correct version is more difficult to maintain. It is easy to produce the following buggy code if the <code>b</code> parameter is removed.</p>

<pre><code>function(a, option) {
    option = arguments.length &gt; 2 ? option : {};
    // ...
}</code></pre>

<p>If your application uses optional parameters with default values, some new syntax would be beneficial for you.</p>

<pre><code>function(a, b, option = {}) {
    // ...
}</code></pre>

<p>The addition of this new syntax tunes the language better to your application&rsquo;s needs.</p>


<h3>Let</h3>

<p>Does the following buggy code look familiar?</p>

<pre><code>for (var i=0, ilen=elements.length; i&lt;ilen; i++) {
    var element = elements[i];
    LIB_addEventListener(element, 'click', function(event) {
        alert('I was originally number ' + i);
    });
}</code></pre>

<p>All the elements were the same number?! The solution is to use an immediately evaluated function expression so each alert reports a different number. This is the &ldquo;let&rdquo; idiom after Lisp&rsquo;s various <code>let</code> forms.</p>

<pre><code>for (var i=0, ilen=elements.length; i&lt;ilen; i++) {
    var element = elements[i];
    (function(num) {
        LIB_addEventListener(element, 'click', function(event) {
            alert('I was originally number ' + num);
        });
    }(i));
}</code></pre>

<p>Sure sometimes delegate listeners might be better than the above code but sometimes the above code is the desired idea. In the above case, we are trying to bind the order of the elements when the loop runs. This order could be lost with the delegate pattern if the elements are rearranged in the DOM.</p>

<p>This syntax is particularly awkward because of the distance between the formal <code>num</code> and actual <code>i</code> parameters of the immediate function.</p>

<p>The immediate function could be factored out to another location and called inside the loop.</p>
    
<pre><code>function attachListener(element, num) {
    LIB_addEventListener(element, 'click', function(event) {
        alert('I was originally number ' + num);
    });
}
for (var i=0, ilen=elements.length; i&lt;ilen; i++) {
    attachListener(elements[i], i);
}</code></pre>
   
<p>Even with this option, sometimes programmers still use the immediate function because it conveys better their intended message to readers.</p>  
 
<p>If your application uses the let idiom, wouldn&rsquo;t it be nice to have new syntax for it?</p>

<pre><code>for (var i=0, ilen=elements.length; i&lt;ilen; i++) {
    var element = elements[i];
    let (num = i) {
        LIB_addEventListener(element, function(event) {
            alert('I was originally number ' + num);
        });
    };
}</code></pre>

<p>With <code>num</code> and <code>i</code> together it is much easier to read this code and a new scope containing <code>new</code> has been introduced so the closure works properly. Once again, the addition of new syntax can tune the language better to your application&rsquo;s needs.</p>


<h3>Modules</h3>

<p>One of the most common idioms in JavaScript programs we all know and love is usually called &ldquo;the module pattern.&rdquo; This idiom provides the benefits of encapsulated variables that are private to the module and imparts sanity to our code.</p>

<pre><code>var event = (function() {

    // private variables
    var listeners = [];
   
    function addEventListener(f) {
        listeners.push(f);
    }

    function clearEventListeners() {
        listeners = [];
    }
    
    // ...
    
    // export the module's API
    return {
        addEventListener: addEventListener,
        clearEventListeners: clearEventListeners
        // ...
    };
}());</code></pre>

<p>The goal of encapsulation here isn&rsquo;t security. It is to ensure that other developers keep their dirty, monkey-patching hands off your module&rsquo;s data.</p>

<p>The exporting can be done a few ways but no matter which way there is some boiler plate.</p>

<p>Importing is verbose also</p>

<pre><code>(function() {

    // import desired properties of the event module
    var addEventListener = event.addEventListener;
    var clearEventListeners = event.clearEventListeners;
    
    // ...
}());</code></pre>

<p>Some new syntax would be nice to convey the intent of the module pattern better.</p>

<pre><code>module event {
    
    // private variables
    var listeners = [];
   
    export function addEventListener(f) {
        listeners.push(f);
    }

    export function clearEventListeners() {
        listeners = [];
    }
    
    // ...
}</code></pre>

<pre><code>(function() {

    import event;
    
    // ...
}());</code></pre>

<p>The module pattern is almost everywhere and some new syntax to better express this idiom would better tune the language to all of our applications.</p>


<h3>Inheritance</h3>

<p>These idiom examples have been growing in how they each span an increasing number of lines of code. The JavaScript idiom that potentially spans the most lines of your program may be the inheritance idiom.</p>

<pre><code>function Employee(first, last, position) {
    // call the superclass constructor
    Person.call(this, first, last);
    this.position = position;
};
// inherit from Person
Employee.prototype = Object.create(Person.prototype);
Employee.prototype.constructor = Employee;

// define an overridding toString() method
Employee.prototype.toString = function() {
    // call superclass's overridden toString() method
    return Person.prototype.toString.call(this) +
           ' is a ' + this.position;
};</code></pre>

<p>What a mess. Yes JavaScript makes single inheritance like this possible by linking prototypes but it takes a lot of code to manually make super things happen they way you might like inheritance to work.</p>

<p>If there could be a maintenance nightmare that is it. The strings &ldquo;Person&rdquo; and &ldquo;Employee&rdquo; are sprawled throughout the code for the Employee &ldquo;class&rdquo;.</p>

<p>If classes with inheritance are a big part of your application, some syntax would really help clean up the code. Perhaps something like the following.</p>

<pre><code>class Employee extends Person {
    constructor(first, last, position) {
        super(first, last);
        public position = position;
    }
 
    update(camera) {
        return super.update() + ' is a ' + position;
    }
}</code></pre>

<p>That is a major improvement.</p>


<h3>Learning from Idioms</h3>

<p>These common idioms make it clear that JavaScript could use some new syntax for several reasons. The ability to do what we want is usually in JavaScript somewhere. The verbosity of the idioms is sometimes too much. We cut corners. Sometimes we avoid certain algorithms because the idioms are too verbose. The idioms are not self explanatory. They are inside secrets of the community and the intent is not easily recognized by outsiders.</p>

<p>The ECMAScript committee has recognized that the above idioms, and others idioms, are common across a wide variety of applications. There are proposals for all of these syntax cases in Harmony. Some of them may make it into the next version of ECMAScript and into the browsers for your use. If new syntax gets there eventually then you can use use it.</p>

<p>Idioms may have emerged in <em>your</em> application that do not appear in a wide variety of applications. For example, Node.js&rsquo;s non-blocking I/O and heavy reliance on callbacks will undoubtedly result in idioms that do not appear in browser scripts. Syntax specific to just your applications will likely never make it into ECMAScript.</p>

<p>If you would like to use specialized syntax for the general idioms like those shown above or you would like syntax for your own idioms, what can you do?</p>


<h2>If Only We Had Macros</h2>

<p>Lisp languages have had full-blown macros for decades. Through macros, Lisp gives programmers the ability to tune the language&rsquo;s syntax to best match their own applications. Because of its macros, Lisp has been described as &ldquo;the programmable programming language.&rdquo; Powerful stuff.</p>

<p>Lisp&rsquo;s s-expression syntax, you know, the syntax with all those parens, gives the language a special property called homoiconicity. It roughly means the syntax of the language is also the syntax of its data structures or that a program&rsquo;s parse tree uses the languages data structures. This homoiconicity makes Lisp&rsquo;s macros possible.</p>

<p>JavaScript doesn&rsquo;t have macros. A major reason for this is that adding macros to languages with C-like syntax, languages that are not homoiconic, is still a research topic. Excerpts from a short conversation on Twitter with littlecalculist, Dave Herman, Ph.D., ECMAScript committee member, and Mozilla Researcher:</p>

<blockquote>
    <dl>
        <dt>@petermichaux</dt>
        <dd>I believe @littlecalculist knows more about the research and possibilities for macros in ECMAScript. I&rsquo;d like to know more also.</dd>
        
        <dt>@littlecalculist<dt>
        <dd>I have thoughts on it for sure. But macros for non-sexp languages is still very much a challenging research topic</dd>

        <dt>@petermichaux<dt>
        <dd>[...] We&rsquo;ll turn blue waiting for macros.</dd>

        <dt>@littlecalculist<dt>
        <dd>Might I suggest you keep breathing? ;-) Seriously, I do hope to try, but trust me, macro system design is hard.</dd>
    </dl>
</blockquote>

<p>The message is pretty clear. JavaScript macros are not just around the corner.</p>


<h2>Harmony Syntax ETA</h2>

<p>Perhaps the syntax extensions in Harmony are all you dream of and more. If Harmony becomes ECMAScript&nbsp;6 and ECMAScript&nbsp;6 becomes ubiquitous then you&rsquo;ll be all set. So all you need to do is wait...patiently.</p>

<p>First, let&rsquo;s look at browser adoption. Unfortunately I&rsquo;ll pick on Internet Explorer a bit, which has almost become a cliche, but not because I have something against the Internet Explorer development team at Microsoft or the newest versions of Internet Explorer. It is necessary to look at this browser because it is perhaps the most important case study for estimating when features will be available for all visitors to your web site.</p>

<p>As of May 2011, <a href=\"http://www.w3schools.com/browsers/browsers_stats.asp\">w3schools</a>, which has relatively tech-savvy visitors, reports Internet Explorer&nbsp;6 still has 2.4% market share. <a href=\"http://marketshare.hitslink.com/browser-market-share.aspx?spider=1&amp;qprid=2\">Net Market Share</a> reports Internet Explorer&nbsp;6 still has 10.36% market share. Your site probably has a market share somewhere between those two numbers but this browser is still hanging on even though it was superseded by Internet Explorer&nbsp;7 in November 2006. How many people are still using Internet Explorer&nbsp;6 or 7? The w3schools site shows 7.7% and Net Market Share shows 18.2%. These browsers just aren&rsquo;t going away fast enough. A publicly available site (e.g. Amazon) cannot afford to ignore market share numbers this large.</p>
    
<p>There is no point in spending any energy moaning that users should upgrade their browsers or that &ldquo;IE should die!&rdquo; It won&rsquo;t happen. I don&rsquo;t know if it is true but someone once said to me &ldquo;Internet Explorer users upgrade their browser when they upgrade their hardware.&rdquo; For the past few years, hardware has certainly become sufficient that people don&rsquo;t need to upgrade anything to use email, Facebook, Twitter, etc.</p>

<p>Suppose your web app is sufficiently advanced that you&rsquo;ve decided that you only care about users with &ldquo;modern&rdquo; browsers. Google Apps recently announced that on August 1, 2011 they will stop supporting Internet Explorer&nbsp;7. That is almost 5 years after Internet Explorer&nbsp;7 was released.</p>
    
<p>Now think about this: Internet Explorer&nbsp;10 is not out yet but, of course, even it won&rsquo;t have Harmony&rsquo;s syntax extensions. Let&rsquo;s estimate that Harmony is approved as ECMAScript&nbsp;6 in mid-2012 and Internet Explorer&nbsp;11 is released in early 2013 with support for all of Harmony&rsquo;s syntax. Five years after that, in 2018, the Google Apps team can drop support for Internet Explorer&nbsp;11 and finally use Harmony syntax freely. (On August 1, 2011, they are also dropping support for the four-year-old Safari&nbsp;3 and two-year-old Firefox&nbsp;3.5 so the waits are still long-ish for other browsers too.)</p>

<p>Amazon developers might need to wait an additional 5&nbsp;years before they can use Harmony syntax. That&rsquo;s 2023!</p>

<p>Will you be satisfied waiting 7-12&nbsp;years before you can start using syntax that would be helpful developing your web apps today? Being more optimistic, even if the wait is just 5&nbsp;years, will you wait?</p>


<h2>JavaScript is Dead.</h2>

<p>Cause of death: semicolon cancer.</p>

<p>Perhaps due to JavaScript&rsquo;s syntax alone, JavaScript does not have macros now and won&rsquo;t have them soon if ever. Millions of programmers use JavaScript now and plenty of them are tired or tiring of the verbose idioms confronting them daily. They want new syntax now and won&rsquo;t wait. For this growing group of developers, JavaScript the source code language is dead.</p>

<p>You had a good reign, JavaScript. We had some good times and wrote some cool apps together. May you rest in peace.</p>


<h2>Long Live JavaScript!</h2>

<p>Programmers like to control their own destiny and they are taking action. You can have all the new syntax you want for your browser scripts, right now, if you write in another source language and compile to the ECMAScript&nbsp;3 dialect of JavaScript for the billions of browsers in the wild. By compiling to ECMAScript&nbsp;3 you are completely freed from JavaScript&rsquo;s syntactic evolution. As an added bonus, you can even <em>fix</em> some of JavaScript&rsquo;s semantic gotchas with a sufficiently sophisticated compiler. JavaScript&rsquo;s new life is as a compilation target.</p>


<h2>Languages that Compile to JavaScript</h2>

<p>There have been compilers to JavaScript for years now. In 2007, I started collecting a list of languages with compilers to JavaScript. There were JavaScript extension languages: the now-defunct ECMAScript&nbsp;4, Narrative JavaScript, and Objective-J. There were pre-existing languages: Scheme, Common Lisp, Smalltalk, Ruby, Python, Java, C#, Haskell, etc. There were even brand new languages HaXe, Milescript, Links, Flapjax that were designed to address web programming needs.</p>

<p>Of these compiler projects, Google&rsquo;s GWT Java-to-JavaScript compiler has probably been the most successful but I don&rsquo;t see programmers who first learned a language other than Java rushing to use Java as their source code language. In fact, none of these compiler projects have accrued a significant long-term user base. At least in the parts of the web that I frequent, with the exception of GWT, it is rare to read about programmers using these compilers for any real projects. There are several legitimate reasons not to use one of these compilers.</p>

<p>Imagine you build a big project using one of these compilers and part way through find a bug in the compiler. The one maintainer of the compiler may have lost interest or time. Do you want to maintain a compiler? Does anyone on your team have the skills to do that? That ulcer is going to get pretty big while you prepare to explain to the CEO that you now need to rewrite the UI in JavaScript.</p>

<p>Just the thought of debugging compiled code when a production bug is filed makes my stomach churn. Core dump. What line number in the source code matches the line number Firebug is reporting for the compiled code? HURRY! That bug needs to be fixed now!!!!</p>

<p>You&rsquo;ve used Objective-J for a big project and now you need to hire a new good programmer. What are your chances of finding the right person? They are probably very low. Just finding an available JavaScript programmer is difficult enough. If you use one of these alternate languages, it is very likely you&rsquo;ll need to train each new person you add to your team.</p>

<p>Even without these compiler projects being wildly successful, the list of languages that compile to JavaScript has continued to grow. There is no doubt that writing a to-JavaScript compiler is a very cool project. Please pay me to write one.</p>

<p>There is one notable new entry in the list of languages that compile to JavaScript that is actually causing a big stir and is possibly changing the game for good.</p>


<h3>CoffeeScript</h3>

<p>I can tell you right now, I don&rsquo;t know why CoffeeScript has the magic combination of features to garner the attention it has when other projects have failed. Significant whitespace and arrow function syntax. My gut reaction is yuck. There is plenty of things to like: default parameter values, rest parameters, spread, destructuring, fixing the whole implied global mess, even classes if you&rsquo;re into that kind of thing and more. Many of CoffeeScript&rsquo;s features are part of Harmony and so may be in browsers sometime in the future but if you use CoffeeScript then you can have them now. There is nothing like instant gratification.</p>

<p>Programmers are bursting with affection for CoffeeScript.</p>

<blockquote>
    <dl>
        <dt>@pyronicide</dt>
        <dd>Being able to use default values for function arguments in #coffeescript makes me immensely happy.</dd>
    </dl>
</blockquote>

<blockquote>
    <dl>
        <dt>@_jdpage</dt>
        <dd>CoffeeScript is wonderful. Now I am spoiled and will complain whenever I have to write JavaScript instead.</dd>
    </dl>
</blockquote>

<p>At the TXJS 2011 conference, Douglas Crockford apparently shared that he thinks &ldquo;CoffeeScript is clearly good stuff.&rdquo;</p>

<p>There is one aspect of the CoffeeScript project that I really like and it is summed up by the following two quotations. The first comes from Trevor Burnham, author of <a href=\"http://pragprog.com/titles/tbcoffee/coffeescript\">CoffeeScript: Accelerated JavaScript Development</a>.</p>

<blockquote>
    <dl>
        <dt>@trevorburnham</dt>
        <dd>[...] It&rsquo;s not about turning JS into Ruby/Python; it&rsquo;s about having a syntax better suited to JavaScript&rsquo;s inner goodness.</dd>
    </dl>
</blockquote>

<p>The second is from <a href=\"http://arcturo.com/library/coffeescript/00_introduction.html\">The Little Book on CoffeeScript</a>.</p>

<blockquote>
    <p>CoffeeScript neatly sidesteps these [JavaScript issues], by only exposing a curated selection of JavaScript features.</p>
</blockquote>

<p>The attitude expressed in these quotations really is great and genius marketing too. It is not CoffeeScript verse JavaScript. It is CoffeeScript enhancing the JavaScript programming experience. Could some different syntax and a restricted subset of JavaScript&rsquo;s features really be better than plain old JavaScript?</p>

<p>Douglas Crockford seems to think so. For years, his <a href=\"http://jslint.com/\">JSLint</a> has been hurting our feelings and demanding that we use very specific whitespace and syntax and that we avoid dangerous JavaScript features. Source code that passes JSLint has access to a true subset of JavaScript: the subset that he calls &ldquo;the good parts.&rdquo; This dialect of JavaScript deserves a name. Maybe GoodScript? After all, you are only allowed to use JSLint for good and not for evil.</p>

<p>The ECMAScript committee also thinks this is a good idea. The <code>\"use strict\"</code> pragma introduced in ECMAScript&nbsp;5 not only restricts some language features like <code>with</code>, strict mode even changes/fixes the semantics of some parts of the language. Because of the semantic changes, ECMAScript&nbsp;5 strict is a different language or at least a different dialect than ECMAScript&nbsp;5 non-strict.</p>

<p>CoffeeScript, GoodScript, and ECMAScript&nbsp;5 strict share common goals of keeping you away from the dangerous parts of JavaScript while giving you access to the valuable, safe parts. Each enforces these goals differently but they are enforced one way or another. You don&rsquo;t get new syntax with GoodScript. It is already JavaScript and ready for the browser. You don&rsquo;t get to use ECMAScript&nbsp;5 strict because it is not available in all browsers yet and won&rsquo;t be for years.</p>

<p>So CoffeeScript seems to be targeting a particular need of web development and maybe that is something other to-JavaScript compilers haven&rsquo;t done or haven&rsquo;t done well before.</p>

<p>CoffeeScript is also a reasonably thin skin over JavaScript. One consequence of this is that the compiled JavaScript code is reasonably easy to read and not brutal to debug (so I&rsquo;m told.) This reduced debugging fear is contributing to interest in CoffeeScript.</p>

<p>CoffeeScript almost feels like a set of macros for writing JavaScript programs.</p>

<p>Since CoffeeScript compilers are in the hands of developers rather than the visitors to sites, you control which version of CoffeeScript you are using. You can upgrade at will. This also means CoffeeScript does not need to be standardized and go through the subsequent painfully slow growth of a standardized language. CoffeeScript can grow at the rate of its community&rsquo;s imagination and desire. JavaScript standardization was essential to the success of the web but the same constraints do not apply to CoffeeScript.</p>


<h2>Well then I&rsquo;m going to invent my own language.</h2>

<p>You can do this and it would be a great exercise. You&rsquo;ll be able to call yourself a compiler writer which is pretty darned prestigious.</p>

<p>The danger of inventing your own language lies in the thinking that you can do better than JavaScript has done <strong>in the long run</strong>. Language design is hard and I bet your language will grow its share of unsightly hairs. Maybe not as many hairs as JavaScript but still. CoffeeScript hasn&rsquo;t hit puberty yet but there are already signs that hair follicles may exist.</p>

<blockquote>
    <dl>
        <dt>@maxsamukha</dt>
        <dd>CoffeeScript: The way variables in outer scopes can be accidentally overwritten is fishy. How bad is it in practice?</dd>
    </dl>
</blockquote>

<p>You were so proud that your simple, readable compiled code was easy to debug. That will become harder as you realize the compiled code&rsquo;s semantics aren&rsquo;t quite what they were supposed to be in corner cases.</p>
    
<p>Idioms will appear in your language and someone will fork your compiler to do away with those idioms (unless your language happens to have macros.)</p>

<p>Enough with this nay saying. Go and write your own language right now. You&rsquo;ll be a better programmer for it.</p>


<h2>What&rsquo;s missing from JavaScript the target language?</h2>

<p>JavaScript is embarking on a new life as a compilation target. It is a capable target for many language features but it could use improvement. In his <a href=\"http://brendaneich.com/2011/05/my-jsconf-us-presentation/\">JSConf.US talk</a>, Brendan Eich stated that one the goals for Harmony is to be a better target for to-JavaScript compilers.</p>

<p>Compiled JavaScript can run slower than hand-written JavaScript just like compiled C can be slower than hand-written Assembly (though not always.) Some inefficiency in compiled JavaScript is tolerable because JavaScript virtual machines are fast and the DOM is the bottleneck anyway. That said, some potential source code languages have semantics sufficiently far from JavaScript&rsquo;s semantics that the compiled code is so inefficient that it cannot realistically be used in production web apps. There are already features in Harmony that will enable some of these languages to be compiled to efficient code and thus make these viable source code languages.</p>


<h3>Proper Tail Calls</h3>

<p>Programs in Lisp languages depend heavily on recursive calls to properly tail recursive procedures. The <a href=\"http://wiki.ecmascript.org/doku.php?id=harmony:proper_tail_calls&amp;s=const\">proper tail calls</a> proposal in Harmony will allow these programs to be compiled to JavaScript without the inefficient trampoline technique currently necessary to avoid overflowing the call stack. Awesome! Let&rsquo;s look at that in a bit more detail.</p>

<p>The following JavaScript is an example of mutually recursive functions which would work fine in Lisp but since JavaScript currently does not have proper tail calls, will overflow the JavaScript call stack when <code>number</code> is large.</p>

<pre><code>function isEven(number) {
    if (number === 0) {
        return true;
    }
    else {
        return isOdd(number - 1);
    }
}

function isOdd(number) {
    if (number === 0) {
        return false;
    }
    else {
        return isEven(number - 1);
    }
}

isEven(100000); // InternalError: too much recursion</code></pre>

<p>In the above code, a call to <code>isEven(100000)</code> isn&rsquo;t complete and removed from the call stack until <code>isOdd(99999)</code> returns which isn&rsquo;t complete and removed from the call stack until <code>isEven(99998)</code> returns and so on. That&rsquo;s a lot of calls on the call stack! And there is no need for them all to be on the call stack. <code>isEven(100000)</code> doesn&rsquo;t have anything intelligent remaining to do once it calls <code>isOdd(99999)</code> because the call to <code>isOdd(99999)</code> is the very last thing in <code>isEven(100000)</code>. The call is said to be in tail position. <code>isEven(100000)</code> is just waiting to return the value returned by <code>isOdd(99999)</code> and a clever language can just pop <code>isEven(100000)</code> off the call stack and replace it with the call to <code>isOdd(99999)</code> thus saving space on the call stack.</p> 

<p>With trampolines we can ensure that even in JavaScript the call stack doesn&rsquo;t grow large. The following is just a sketch of how trampolines might be implemented and how <code>isEven</code> and <code>isOdd</code> might be compiled for a JavaScript interpreter that doesn&rsquo;t have proper tail calls.</p>

<pre><code>function bounce(ret) {
    while (typeof ret === 'function') {
        ret = ret();
    }
    return ret;
}

function isEven(number) {
    if (number === 0) {
        return true;
    }
    else {
        return function() {
            return isOdd(number - 1);
        };
    }
}

function isOdd(number) {
    if (number === 0) {
        return false;
    }
    else {
        return function() {
            return isEven(number - 1);
        };
    }
}

bounce(function() {return isEven(100000);}); // true</code></pre>

<p>You can see the extra overhead of the <code>bounce</code> function which implements the trampoline calls is quite onerous. It creates closures for each continuation, doubles the number of calls, and must examine the returned value after each bounce; however, <code>isEven(10000)</code> does complete and is removed from the callstack <em>before</em> <code>isOdd(99999)</code> is called. The full computation completes in constant call stack space.</p>

<p>The bottom line is trampolines incur too much overhead. They incur so much overhead that when Rich Hickey created Clojure, his Lisp for the JVM, he decided his language could not have proper tail calls because trampolines were too expensive. That must have been a painful decision for someone who loves the Lisp family of languages.</p>

<p>The good news is that the ECMAScript committee has recognized this deficiency in JavaScript and has added proper tail calls to Harmony. This will benefit programmers writing directly in JavaScript and developers of to-JavaScript compilers.</p>


<h3>Lambdas</h3>

<p>Another strawman proposal not yet promoted to Harmony is the <a href=\"http://wiki.ecmascript.org/doku.php?id=strawman:block_lambda_revival\">Block Lambda Revival</a> which combines some new syntax with a new language construct called a lambda. A lambda is a callable thing, like a function, but it obeys Tennent&rsquo;s Correspondence Principle. Tennent&rsquo;s Correspondence Principle states that wrapping an expression or block of code in an immediate lambda should not change the meaning of that wrapped code. JavaScript functions are not lambdas and do not obey Tennent&rsquo;s Correspondence Principle. For example,</p>

<pre><code>function one() {
    return 1;
}

one(); // 1</code></pre>

<p>is not the same when the return line is wrapped in an immediate function</p>

<pre><code>function one() {
    (function() {
        return 1;
    }());
}

one(); // undefined</code></pre>

<p>The syntax of the block lambda proposal for a lambda that takes two arguments and sums them is <code>{|a,&nbsp;b|&nbsp;a&nbsp;+&nbsp;b}</code></p>

<p>Using the syntax of the block lambda proposal  we can wrap the return line in an immediate lambda without changing the meaning.</p>

<pre><code>function one() {
    ({||
        return 1;
    }());
}

one(); // 1</code></pre>

<p>Thanks to lambdas obeying Tennent&rsquo;s Correspondence Principle, the <code>return</code> still means return from the function <code>one</code>.</p>

<p>You may ask &ldquo;Who cares about this computer science-y stuff?&rdquo; to which I reply &ldquo;Did any of that macro business seem useful?&rdquo; because lambdas are a fundamental building block in the code generated by many macros. And since lambdas play nicely with JavaScript&rsquo;s <code>return</code>, <code>arguments</code>, and <code>this</code>, lambdas would be a valuable addition to the language for compiler writers.</p>

<p>I&rsquo;m focusing on the JavaScript-as-a-target aspect of the block lambda proposal. If you plan on writing in JavaScript forever after, the proposal has other benefits for you too that don&rsquo;t matter to compiler writers.</p>

<p>The block lambda strawman has not yet been promoted to Harmony and so currently doesn&rsquo;t have a path into ECMAScript&nbsp;6 and browsers around the world. The standardization process is slow. Maybe there will be another decade stall in evolving the language like there was after ECMAScript&nbsp;3. Maybe the next edition of ECMAScript will be the last edition. Better to get the best stuff in there than hope to get it in later. If you care about the future of JavaScript and think lambdas would be a benefit to the language then <strong>let the ECMAScript committee know by sending a message to the <a href=\"https://mail.mozilla.org/listinfo/es-discuss\">es-discuss mailing list</a> in support of the block lambda proposal</strong>. Powerful, orthogonal language features like tail calls and lambdas which have no efficient workarounds may be the most important additions in the next edition of ECMAScript.</p>


<h2>What&rsquo;s missing from the browser?</h2>

<p>The browser can help JavaScript succeed in its new life as a compilation target. The browser interprets compiled JavaScript and complains when the compiled code has an error. The error messages contain line numbers in the compiled code but you want to know the line number in source code.</p>

<p>The Mozilla crowd has <a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=618650\">an open ticket</a> and <a href=\"https://wiki.mozilla.org/DevTools/Features/SourceMap\">a dev tools project</a> to ease debugging source code by mapping compiled code lines to source code lines. Since you control the browser in which you primarily develop and test, you can use this feature as soon as it is ready.</p>

<p>Somewhere I read that the Webkit folks are developing similar source code debugging assistance but I cannot find any concrete evidence.</p>


<h2>Polyglot</h2>

<p>JavaScript&rsquo;s monopoly in the browser has meant front-end programmers all speak the same language. This has given the community a <i>lingua franca</i> enabling good communication and code sharing. We are now headed for a polyglot future where you choose the language(s) you want to learn and use for developing browser applications. Maybe you are only using a few JavaScript language extensions via <a href=\"http://code.google.com/p/traceur-compiler/\">Traceur</a> and compiling templates to JavaScript with <a href=\"http://mustache.github.com/\">Mustache</a>. This still means that the CoffeeScript programmer won&rsquo;t understand your source code immediately.</p>

<p>This divergence was inevitable as it has happened on all previously successful platforms. There have been multiple languages for building native applications almost forever. C is still common but C++, Objective-C, and many other languages are available. The JVM was intended to run programs written in Java but clever developers have added other languages like Clojure and JRuby as options. Microsoft recognized what seems to be a human psychological need for a variety of languages and developed its .NET CLR platform for multiple languages from the beginning. Programs written in Basic, C#, IronPython, etc can all be run on the CLR.</p>

<p>Barriors to communication in the front-end community are not new anyway. A developer using Dojo cannot immediately understand the source code of an application written with jQuery or YUI. There is a plethora of libraries, some very different, that add the ideas of class-based inheritance to JavaScript. So we already have our barriors even within JavaScript.</p>

<p>Having multiple source languages will increase the barriers in our community. Programmers will still need to know JavaScript, at least for a while, but in a few years they may know other source languages better then they know JavaScript.</p>

<p>Choice is a blessing and a curse.</p>


<h2>Summary</h2>

<p>It is great having the opportunity to watch JavaScript&rsquo;s transition to a new life as it happens. It&rsquo;s impossible to say which languages will end up winning market share in the to-JavaScript compilation but it is sure to be interesting. CoffeeScript is gaining momentum now but I think many other successful source code languages will follow.</p>

<p>What do you think will happen?</p>


"))) ("SICP Classes for JavaScript" "<p><strong>Warning:</strong> This article is intended for JavaScript programmers. Parens are coming but only briefly and you can handle it and it will be good for you.</p>
<p>In <strong>Structure and Interpretation of Programming Languages Second Edition</strong> (SICP) on page 182, the authors introduce the idea of <i>message passing</i> with the following example in Scheme of a complex number constructor function.</p>
<pre><code>(define (make-from-real-imag x y)
(define (dispatch op)
(cond ((eq? op 'real-part) x)
((eq? op 'imag-part) y)
((eq? op 'magnitude)
(sqrt (+ (square x) (square y))))
((eq? op 'angle) (atan y x))
(else
(error \"Uknown op -- MAKE-FROM-REAL-IMAG\" op))))
dispatch)</code></pre>
<p>The important part to note here is that the value returned by the <code>make-from-real-imag</code> constructor function is actually a dispatch procedure that you can call with a message argument. You can send messages to get the real part or magnitude of the complex number.</p>
<pre><code>(define c (make-from-real-imag 3 4))
(c 'real-part) ; 3
(c 'imag-part) ; 4
(c 'magnitude) ; 5
(c 'angle)     ; 0.927295218001612
(c 'asdf)      ; ERROR: Uknown op -- MAKE-FROM-REAL-IMAG: asdf</code></pre>
<p>Let&rsquo;s see what the above code looks like in JavaScript, our <i>lingua franca</i>.</p>
<pre><code>function makeFromRealImag(x, y) {
function dispatch(op) {
switch (op) {
case 'realPart': return x;
case 'imagPart': return y;
case 'magnitude':
return Math.sqrt(x*x + y*y);
case 'angle': return Math.atan2(y, x);
default:
throw 'Unknown op -- makeFromRealImag: ' + op;
}
}
return dispatch;
}
var c = makeFromRealImag(3, 4);
c('realPart');  // 3
c('imagPart');  // 4
c('magnitude'); // 5
c('angle');     // 0.9272952180016122
c('asdf');      // \"Unknown op -- makeFromRealImag: asdf\"</code></pre>
<p>Now this probably doesn&rsquo;t look like any object-oriented JavaScript you&rsquo;ve seen before but it illustrates an important point. In JavaScript, we can represent the idea of an object as a function of its messages. The constructor function returns a dispatch function that you wrote that can dispatch any message any way that you want it to. This immediately gives you Spidermonkey&rsquo;s <code>__nosuchmethod__</code>, Smalltalk&rsquo;s <code>doesNotUnderstand</code>, and Ruby&rsquo;s <code>method_missing</code>. Powerful stuff but unfortunately the JavaScript code above runs very slowly. We can move towards a faster and more familiar JavaScript style.</p>
<p>SICP page 223, introduces the idea of mutable objects but the most interesting point is the variation on the dispatch procedure.</p>
<pre><code>(define (make-account balance)
(define (withdraw amount)
(if (>= balance amount)
(begin (set! balance (- balance amount))
balance)
\"Insufficient funds\"))
(define (deposit amount)
(set! balance (+ balance amount))
balance)
(define (dispatch m)
(cond ((eq? m 'withdraw) withdraw)
((eq? m 'deposit) deposit)
(else (error \"Unknown request -- MAKE-ACCOUNT\"
m))))
dispatch)
(define account (make-account 10))
((account 'deposit) 5)  ; 15
((account 'withdraw) 3) ; 12</code></pre>
<p>Converting this to JavaScript we have the following.</p>
<pre><code>function makeAccount(balance) {
function withdraw(amount) {
if (balance >= amount) {
balance = balance - amount;
return balance;
}
return \"Insufficient funds\";
}
function deposit(amount) {
balance = balance + amount;
return balance;
}
function dispatch(m) {
switch (m) {
case 'withdraw': return withdraw;
case 'deposit': return deposit;
default:
throw \"Unknown request -- makeAccount: \" + m;
}
}
return dispatch;
}
var account = makeAccount(10);
account('deposit')(5);  // 15
account('withdraw')(3); // 12</code></pre>
<p>The way the <code>dispatch</code> function works for accounts is quite different than in the complex numbers case. In the case of complex numbers, when a message was sent to the <code>dispatch</code> function, it executed the associated operation (i.e. the method) immediately. In contrast, the account <code>dispatch</code> function returns the method associated with the message and that method can then be called.</p>
<p>This is very similar to how JavaScript&rsquo;s <code>reciever.message(arg)</code> syntax works and we can move to a more familiar object-oriented JavaScript style.</p>
<pre><code>function makeAccount(balance) {
function withdraw(amount) {
if (balance >= amount) {
balance = balance - amount;
return balance;
}
return \"Insufficient funds\";
}
function deposit(amount) {
balance = balance + amount;
return balance;
}
return {
withdraw: withdraw,
deposit: deposit
};
}
var account = makeAccount(10);
account.deposit(5);  // 15
account.withdraw(3); // 12</code></pre>
<p>In this last version, we&rsquo;ve stopped writing our own dispatch logic and use JavaScript&rsquo;s built-in property lookup. This increases speed significantly. We&rsquo;ve lost the ability to do the <code>__noSuchMethod__</code> type of dispatching when using standard ECMAScript but that doesn&rsquo;t seem to be commonly useful anyway.</p>
<p>For the well-read JavaScript programmers out there, you may recognize this last version as <i>durable objects</i> from Douglas Crockford&rsquo;s book <strong>JavaScript: The Good Parts</strong>.</p>
<p>I find it interesting that the word &ldquo;inheritance&rdquo; does not appear in SICP&rsquo;s index even though the book goes on to implement complex programs like language interpreters and compilers in a message passing style. That shows this simple style of object-oriented programming can take you far.</p>
<p>The moral of the story is that old books are worth reading and can change the way you program today. You can even <a href=\"http://mitpress.mit.edu/sicp/\">read SICP for free</a>.</p>" "/articles/sicp-classes-for-javascript" (19947 28368) old 9 nil nil ((id nil "http://peter.michaux.ca/articles/sicp-classes-for-javascript") (title nil "SICP Classes for JavaScript") (updated nil "2011-06-05T11:56:00Z") (link ((href . "/articles/sicp-classes-for-javascript") (rel . "alternate") (type . "text/html"))) (content ((type . "html")) "<p><strong>Warning:</strong> This article is intended for JavaScript programmers. Parens are coming but only briefly and you can handle it and it will be good for you.</p>

<p>In <strong>Structure and Interpretation of Programming Languages Second Edition</strong> (SICP) on page 182, the authors introduce the idea of <i>message passing</i> with the following example in Scheme of a complex number constructor function.</p>

<pre><code>(define (make-from-real-imag x y)
  (define (dispatch op)
    (cond ((eq? op 'real-part) x)
          ((eq? op 'imag-part) y)
          ((eq? op 'magnitude)
           (sqrt (+ (square x) (square y))))
          ((eq? op 'angle) (atan y x))
          (else
           (error \"Uknown op -- MAKE-FROM-REAL-IMAG\" op))))
  dispatch)</code></pre>

<p>The important part to note here is that the value returned by the <code>make-from-real-imag</code> constructor function is actually a dispatch procedure that you can call with a message argument. You can send messages to get the real part or magnitude of the complex number.</p>

<pre><code>(define c (make-from-real-imag 3 4))
(c 'real-part) ; 3
(c 'imag-part) ; 4
(c 'magnitude) ; 5
(c 'angle)     ; 0.927295218001612
(c 'asdf)      ; ERROR: Uknown op -- MAKE-FROM-REAL-IMAG: asdf</code></pre>


<p>Let&rsquo;s see what the above code looks like in JavaScript, our <i>lingua franca</i>.</p>

<pre><code>function makeFromRealImag(x, y) {
    function dispatch(op) {
        switch (op) {
            case 'realPart': return x;
            case 'imagPart': return y;
            case 'magnitude':
                return Math.sqrt(x*x + y*y);
            case 'angle': return Math.atan2(y, x);
            default:
                throw 'Unknown op -- makeFromRealImag: ' + op;
        }
    }
    return dispatch;
}

var c = makeFromRealImag(3, 4);
c('realPart');  // 3
c('imagPart');  // 4
c('magnitude'); // 5
c('angle');     // 0.9272952180016122
c('asdf');      // \"Unknown op -- makeFromRealImag: asdf\"</code></pre>

<p>Now this probably doesn&rsquo;t look like any object-oriented JavaScript you&rsquo;ve seen before but it illustrates an important point. In JavaScript, we can represent the idea of an object as a function of its messages. The constructor function returns a dispatch function that you wrote that can dispatch any message any way that you want it to. This immediately gives you Spidermonkey&rsquo;s <code>__nosuchmethod__</code>, Smalltalk&rsquo;s <code>doesNotUnderstand</code>, and Ruby&rsquo;s <code>method_missing</code>. Powerful stuff but unfortunately the JavaScript code above runs very slowly. We can move towards a faster and more familiar JavaScript style.</p>

<p>SICP page 223, introduces the idea of mutable objects but the most interesting point is the variation on the dispatch procedure.</p>

<pre><code>(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        \"Insufficient funds\"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (error \"Unknown request -- MAKE-ACCOUNT\"
                       m))))
  dispatch)

(define account (make-account 10))
((account 'deposit) 5)  ; 15
((account 'withdraw) 3) ; 12</code></pre>

<p>Converting this to JavaScript we have the following.</p>

<pre><code>function makeAccount(balance) {
    function withdraw(amount) {
        if (balance >= amount) {
            balance = balance - amount;
            return balance;
        }
        return \"Insufficient funds\";
    }
    function deposit(amount) {
        balance = balance + amount;
        return balance;
    }
    function dispatch(m) {
        switch (m) {
            case 'withdraw': return withdraw;
            case 'deposit': return deposit;
            default:
                throw \"Unknown request -- makeAccount: \" + m;
        }
    }
    return dispatch;
}

var account = makeAccount(10);
account('deposit')(5);  // 15
account('withdraw')(3); // 12</code></pre>

<p>The way the <code>dispatch</code> function works for accounts is quite different than in the complex numbers case. In the case of complex numbers, when a message was sent to the <code>dispatch</code> function, it executed the associated operation (i.e. the method) immediately. In contrast, the account <code>dispatch</code> function returns the method associated with the message and that method can then be called.</p>

<p>This is very similar to how JavaScript&rsquo;s <code>reciever.message(arg)</code> syntax works and we can move to a more familiar object-oriented JavaScript style.</p>

<pre><code>function makeAccount(balance) {
    function withdraw(amount) {
        if (balance >= amount) {
            balance = balance - amount;
            return balance;
        }
        return \"Insufficient funds\";
    }
    function deposit(amount) {
        balance = balance + amount;
        return balance;
    }
    return {
      withdraw: withdraw,
      deposit: deposit
    };
}

var account = makeAccount(10);
account.deposit(5);  // 15
account.withdraw(3); // 12</code></pre>

<p>In this last version, we&rsquo;ve stopped writing our own dispatch logic and use JavaScript&rsquo;s built-in property lookup. This increases speed significantly. We&rsquo;ve lost the ability to do the <code>__noSuchMethod__</code> type of dispatching when using standard ECMAScript but that doesn&rsquo;t seem to be commonly useful anyway.</p>

<p>For the well-read JavaScript programmers out there, you may recognize this last version as <i>durable objects</i> from Douglas Crockford&rsquo;s book <strong>JavaScript: The Good Parts</strong>.</p>

<p>I find it interesting that the word &ldquo;inheritance&rdquo; does not appear in SICP&rsquo;s index even though the book goes on to implement complex programs like language interpreters and compilers in a message passing style. That shows this simple style of object-oriented programming can take you far.</p>

<p>The moral of the story is that old books are worth reading and can change the way you program today. You can even <a href=\"http://mitpress.mit.edu/sicp/\">read SICP for free</a>.</p>


"))) ("Now with Tweets" "<p>I'm giving Twitter a try. If you <a href=\"http://twitter.com/petermichaux\">follow me</a> then you can watch the experiment unfold.</p>" "/articles/now-with-tweets" (19937 21628) old 10 nil nil ((id nil "http://peter.michaux.ca/articles/now-with-tweets") (title nil "Now with Tweets") (updated nil "2011-05-28T20:01:00Z") (link ((href . "/articles/now-with-tweets") (rel . "alternate") (type . "text/html"))) (content ((type . "html")) "<p>I'm giving Twitter a try. If you <a href=\"http://twitter.com/petermichaux\">follow me</a> then you can watch the experiment unfold.</p>
"))))